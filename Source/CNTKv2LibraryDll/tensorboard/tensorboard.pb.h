// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: tensorboard.proto

#ifndef PROTOBUF_tensorboard_2eproto__INCLUDED
#define PROTOBUF_tensorboard_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3001000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3001000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/map.h>
#include <google/protobuf/map_field_inl.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace tensorflow {

// Internal implementation detail -- do not call these.
void protobuf_AddDesc_tensorboard_2eproto();
void protobuf_InitDefaults_tensorboard_2eproto();
void protobuf_AssignDesc_tensorboard_2eproto();
void protobuf_ShutdownFile_tensorboard_2eproto();

class AttrValue;
class AttrValue_ListValue;
class Event;
class GraphDef;
class HistogramProto;
class LogMessage;
class NameAttrList;
class NodeDef;
class SessionLog;
class Summary;
class SummaryDescription;
class Summary_Audio;
class Summary_Image;
class Summary_Value;
class TaggedRunMetadata;
class TensorProto;
class TensorShapeProto;
class TensorShapeProto_Dim;
class VersionDef;

enum LogMessage_Level {
  LogMessage_Level_UNKNOWN = 0,
  LogMessage_Level_DEBUG = 10,
  LogMessage_Level_INFO = 20,
  LogMessage_Level_WARN = 30,
  LogMessage_Level_ERROR = 40,
  LogMessage_Level_FATAL = 50,
  LogMessage_Level_LogMessage_Level_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  LogMessage_Level_LogMessage_Level_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool LogMessage_Level_IsValid(int value);
const LogMessage_Level LogMessage_Level_Level_MIN = LogMessage_Level_UNKNOWN;
const LogMessage_Level LogMessage_Level_Level_MAX = LogMessage_Level_FATAL;
const int LogMessage_Level_Level_ARRAYSIZE = LogMessage_Level_Level_MAX + 1;

const ::google::protobuf::EnumDescriptor* LogMessage_Level_descriptor();
inline const ::std::string& LogMessage_Level_Name(LogMessage_Level value) {
  return ::google::protobuf::internal::NameOfEnum(
    LogMessage_Level_descriptor(), value);
}
inline bool LogMessage_Level_Parse(
    const ::std::string& name, LogMessage_Level* value) {
  return ::google::protobuf::internal::ParseNamedEnum<LogMessage_Level>(
    LogMessage_Level_descriptor(), name, value);
}
enum SessionLog_SessionStatus {
  SessionLog_SessionStatus_STATUS_UNSPECIFIED = 0,
  SessionLog_SessionStatus_START = 1,
  SessionLog_SessionStatus_STOP = 2,
  SessionLog_SessionStatus_CHECKPOINT = 3,
  SessionLog_SessionStatus_SessionLog_SessionStatus_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  SessionLog_SessionStatus_SessionLog_SessionStatus_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool SessionLog_SessionStatus_IsValid(int value);
const SessionLog_SessionStatus SessionLog_SessionStatus_SessionStatus_MIN = SessionLog_SessionStatus_STATUS_UNSPECIFIED;
const SessionLog_SessionStatus SessionLog_SessionStatus_SessionStatus_MAX = SessionLog_SessionStatus_CHECKPOINT;
const int SessionLog_SessionStatus_SessionStatus_ARRAYSIZE = SessionLog_SessionStatus_SessionStatus_MAX + 1;

const ::google::protobuf::EnumDescriptor* SessionLog_SessionStatus_descriptor();
inline const ::std::string& SessionLog_SessionStatus_Name(SessionLog_SessionStatus value) {
  return ::google::protobuf::internal::NameOfEnum(
    SessionLog_SessionStatus_descriptor(), value);
}
inline bool SessionLog_SessionStatus_Parse(
    const ::std::string& name, SessionLog_SessionStatus* value) {
  return ::google::protobuf::internal::ParseNamedEnum<SessionLog_SessionStatus>(
    SessionLog_SessionStatus_descriptor(), name, value);
}
enum DataType {
  DT_INVALID = 0,
  DT_FLOAT = 1,
  DT_DOUBLE = 2,
  DT_INT32 = 3,
  DT_UINT8 = 4,
  DT_INT16 = 5,
  DT_INT8 = 6,
  DT_STRING = 7,
  DT_COMPLEX64 = 8,
  DT_INT64 = 9,
  DT_BOOL = 10,
  DT_QINT8 = 11,
  DT_QUINT8 = 12,
  DT_QINT32 = 13,
  DT_BFLOAT16 = 14,
  DT_QINT16 = 15,
  DT_QUINT16 = 16,
  DT_UINT16 = 17,
  DT_COMPLEX128 = 18,
  DT_HALF = 19,
  DT_RESOURCE = 20,
  DT_FLOAT_REF = 101,
  DT_DOUBLE_REF = 102,
  DT_INT32_REF = 103,
  DT_UINT8_REF = 104,
  DT_INT16_REF = 105,
  DT_INT8_REF = 106,
  DT_STRING_REF = 107,
  DT_COMPLEX64_REF = 108,
  DT_INT64_REF = 109,
  DT_BOOL_REF = 110,
  DT_QINT8_REF = 111,
  DT_QUINT8_REF = 112,
  DT_QINT32_REF = 113,
  DT_BFLOAT16_REF = 114,
  DT_QINT16_REF = 115,
  DT_QUINT16_REF = 116,
  DT_UINT16_REF = 117,
  DT_COMPLEX128_REF = 118,
  DT_HALF_REF = 119,
  DT_RESOURCE_REF = 120,
  DataType_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  DataType_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool DataType_IsValid(int value);
const DataType DataType_MIN = DT_INVALID;
const DataType DataType_MAX = DT_RESOURCE_REF;
const int DataType_ARRAYSIZE = DataType_MAX + 1;

const ::google::protobuf::EnumDescriptor* DataType_descriptor();
inline const ::std::string& DataType_Name(DataType value) {
  return ::google::protobuf::internal::NameOfEnum(
    DataType_descriptor(), value);
}
inline bool DataType_Parse(
    const ::std::string& name, DataType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<DataType>(
    DataType_descriptor(), name, value);
}
// ===================================================================

class TensorShapeProto_Dim : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:tensorflow.TensorShapeProto.Dim) */ {
 public:
  TensorShapeProto_Dim();
  virtual ~TensorShapeProto_Dim();

  TensorShapeProto_Dim(const TensorShapeProto_Dim& from);

  inline TensorShapeProto_Dim& operator=(const TensorShapeProto_Dim& from) {
    CopyFrom(from);
    return *this;
  }

  inline ::google::protobuf::Arena* GetArena() const { return GetArenaNoVirtual(); }
  inline void* GetMaybeArenaPointer() const {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const TensorShapeProto_Dim& default_instance();

  static const TensorShapeProto_Dim* internal_default_instance();

  void UnsafeArenaSwap(TensorShapeProto_Dim* other);
  void Swap(TensorShapeProto_Dim* other);

  // implements Message ----------------------------------------------

  inline TensorShapeProto_Dim* New() const { return New(NULL); }

  TensorShapeProto_Dim* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TensorShapeProto_Dim& from);
  void MergeFrom(const TensorShapeProto_Dim& from);
  void Clear();
  bool IsInitialized() const;

  size_t ByteSizeLong() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(TensorShapeProto_Dim* other);
  void UnsafeMergeFrom(const TensorShapeProto_Dim& from);
  protected:
  explicit TensorShapeProto_Dim(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int64 size = 1;
  void clear_size();
  static const int kSizeFieldNumber = 1;
  ::google::protobuf::int64 size() const;
  void set_size(::google::protobuf::int64 value);

  // optional string name = 2;
  void clear_name();
  static const int kNameFieldNumber = 2;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);
  ::std::string* unsafe_arena_release_name();
  void unsafe_arena_set_allocated_name(
      ::std::string* name);

  // @@protoc_insertion_point(class_scope:tensorflow.TensorShapeProto.Dim)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  friend class ::google::protobuf::Arena;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::int64 size_;
  mutable int _cached_size_;
  friend void  protobuf_InitDefaults_tensorboard_2eproto_impl();
  friend void  protobuf_AddDesc_tensorboard_2eproto_impl();
  friend void protobuf_AssignDesc_tensorboard_2eproto();
  friend void protobuf_ShutdownFile_tensorboard_2eproto();

  void InitAsDefaultInstance();
};
extern ::google::protobuf::internal::ExplicitlyConstructed<TensorShapeProto_Dim> TensorShapeProto_Dim_default_instance_;

// -------------------------------------------------------------------

class TensorShapeProto : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:tensorflow.TensorShapeProto) */ {
 public:
  TensorShapeProto();
  virtual ~TensorShapeProto();

  TensorShapeProto(const TensorShapeProto& from);

  inline TensorShapeProto& operator=(const TensorShapeProto& from) {
    CopyFrom(from);
    return *this;
  }

  inline ::google::protobuf::Arena* GetArena() const { return GetArenaNoVirtual(); }
  inline void* GetMaybeArenaPointer() const {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const TensorShapeProto& default_instance();

  static const TensorShapeProto* internal_default_instance();

  void UnsafeArenaSwap(TensorShapeProto* other);
  void Swap(TensorShapeProto* other);

  // implements Message ----------------------------------------------

  inline TensorShapeProto* New() const { return New(NULL); }

  TensorShapeProto* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TensorShapeProto& from);
  void MergeFrom(const TensorShapeProto& from);
  void Clear();
  bool IsInitialized() const;

  size_t ByteSizeLong() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(TensorShapeProto* other);
  void UnsafeMergeFrom(const TensorShapeProto& from);
  protected:
  explicit TensorShapeProto(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef TensorShapeProto_Dim Dim;

  // accessors -------------------------------------------------------

  // repeated .tensorflow.TensorShapeProto.Dim dim = 2;
  int dim_size() const;
  void clear_dim();
  static const int kDimFieldNumber = 2;
  const ::tensorflow::TensorShapeProto_Dim& dim(int index) const;
  ::tensorflow::TensorShapeProto_Dim* mutable_dim(int index);
  ::tensorflow::TensorShapeProto_Dim* add_dim();
  ::google::protobuf::RepeatedPtrField< ::tensorflow::TensorShapeProto_Dim >*
      mutable_dim();
  const ::google::protobuf::RepeatedPtrField< ::tensorflow::TensorShapeProto_Dim >&
      dim() const;

  // optional bool unknown_rank = 3;
  void clear_unknown_rank();
  static const int kUnknownRankFieldNumber = 3;
  bool unknown_rank() const;
  void set_unknown_rank(bool value);

  // @@protoc_insertion_point(class_scope:tensorflow.TensorShapeProto)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  friend class ::google::protobuf::Arena;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::RepeatedPtrField< ::tensorflow::TensorShapeProto_Dim > dim_;
  bool unknown_rank_;
  mutable int _cached_size_;
  friend void  protobuf_InitDefaults_tensorboard_2eproto_impl();
  friend void  protobuf_AddDesc_tensorboard_2eproto_impl();
  friend void protobuf_AssignDesc_tensorboard_2eproto();
  friend void protobuf_ShutdownFile_tensorboard_2eproto();

  void InitAsDefaultInstance();
};
extern ::google::protobuf::internal::ExplicitlyConstructed<TensorShapeProto> TensorShapeProto_default_instance_;

// -------------------------------------------------------------------

class TensorProto : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:tensorflow.TensorProto) */ {
 public:
  TensorProto();
  virtual ~TensorProto();

  TensorProto(const TensorProto& from);

  inline TensorProto& operator=(const TensorProto& from) {
    CopyFrom(from);
    return *this;
  }

  inline ::google::protobuf::Arena* GetArena() const { return GetArenaNoVirtual(); }
  inline void* GetMaybeArenaPointer() const {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const TensorProto& default_instance();

  static const TensorProto* internal_default_instance();

  void UnsafeArenaSwap(TensorProto* other);
  void Swap(TensorProto* other);

  // implements Message ----------------------------------------------

  inline TensorProto* New() const { return New(NULL); }

  TensorProto* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TensorProto& from);
  void MergeFrom(const TensorProto& from);
  void Clear();
  bool IsInitialized() const;

  size_t ByteSizeLong() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(TensorProto* other);
  void UnsafeMergeFrom(const TensorProto& from);
  protected:
  explicit TensorProto(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .tensorflow.DataType dtype = 1;
  void clear_dtype();
  static const int kDtypeFieldNumber = 1;
  ::tensorflow::DataType dtype() const;
  void set_dtype(::tensorflow::DataType value);

  // optional .tensorflow.TensorShapeProto tensor_shape = 2;
  bool has_tensor_shape() const;
  void clear_tensor_shape();
  static const int kTensorShapeFieldNumber = 2;
  private:
  void _slow_mutable_tensor_shape();
  void _slow_set_allocated_tensor_shape(
      ::google::protobuf::Arena* message_arena, ::tensorflow::TensorShapeProto** tensor_shape);
  ::tensorflow::TensorShapeProto* _slow_release_tensor_shape();
  public:
  const ::tensorflow::TensorShapeProto& tensor_shape() const;
  ::tensorflow::TensorShapeProto* mutable_tensor_shape();
  ::tensorflow::TensorShapeProto* release_tensor_shape();
  void set_allocated_tensor_shape(::tensorflow::TensorShapeProto* tensor_shape);
  ::tensorflow::TensorShapeProto* unsafe_arena_release_tensor_shape();
  void unsafe_arena_set_allocated_tensor_shape(
      ::tensorflow::TensorShapeProto* tensor_shape);

  // optional int32 version_number = 3;
  void clear_version_number();
  static const int kVersionNumberFieldNumber = 3;
  ::google::protobuf::int32 version_number() const;
  void set_version_number(::google::protobuf::int32 value);

  // optional bytes tensor_content = 4;
  void clear_tensor_content();
  static const int kTensorContentFieldNumber = 4;
  const ::std::string& tensor_content() const;
  void set_tensor_content(const ::std::string& value);
  void set_tensor_content(const char* value);
  void set_tensor_content(const void* value, size_t size);
  ::std::string* mutable_tensor_content();
  ::std::string* release_tensor_content();
  void set_allocated_tensor_content(::std::string* tensor_content);
  ::std::string* unsafe_arena_release_tensor_content();
  void unsafe_arena_set_allocated_tensor_content(
      ::std::string* tensor_content);

  // repeated int32 half_val = 13 [packed = true];
  int half_val_size() const;
  void clear_half_val();
  static const int kHalfValFieldNumber = 13;
  ::google::protobuf::int32 half_val(int index) const;
  void set_half_val(int index, ::google::protobuf::int32 value);
  void add_half_val(::google::protobuf::int32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      half_val() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_half_val();

  // repeated float float_val = 5 [packed = true];
  int float_val_size() const;
  void clear_float_val();
  static const int kFloatValFieldNumber = 5;
  float float_val(int index) const;
  void set_float_val(int index, float value);
  void add_float_val(float value);
  const ::google::protobuf::RepeatedField< float >&
      float_val() const;
  ::google::protobuf::RepeatedField< float >*
      mutable_float_val();

  // repeated double double_val = 6 [packed = true];
  int double_val_size() const;
  void clear_double_val();
  static const int kDoubleValFieldNumber = 6;
  double double_val(int index) const;
  void set_double_val(int index, double value);
  void add_double_val(double value);
  const ::google::protobuf::RepeatedField< double >&
      double_val() const;
  ::google::protobuf::RepeatedField< double >*
      mutable_double_val();

  // repeated int32 int_val = 7 [packed = true];
  int int_val_size() const;
  void clear_int_val();
  static const int kIntValFieldNumber = 7;
  ::google::protobuf::int32 int_val(int index) const;
  void set_int_val(int index, ::google::protobuf::int32 value);
  void add_int_val(::google::protobuf::int32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      int_val() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_int_val();

  // repeated bytes string_val = 8;
  int string_val_size() const;
  void clear_string_val();
  static const int kStringValFieldNumber = 8;
  const ::std::string& string_val(int index) const;
  ::std::string* mutable_string_val(int index);
  void set_string_val(int index, const ::std::string& value);
  void set_string_val(int index, const char* value);
  void set_string_val(int index, const void* value, size_t size);
  ::std::string* add_string_val();
  void add_string_val(const ::std::string& value);
  void add_string_val(const char* value);
  void add_string_val(const void* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& string_val() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_string_val();

  // repeated float scomplex_val = 9 [packed = true];
  int scomplex_val_size() const;
  void clear_scomplex_val();
  static const int kScomplexValFieldNumber = 9;
  float scomplex_val(int index) const;
  void set_scomplex_val(int index, float value);
  void add_scomplex_val(float value);
  const ::google::protobuf::RepeatedField< float >&
      scomplex_val() const;
  ::google::protobuf::RepeatedField< float >*
      mutable_scomplex_val();

  // repeated int64 int64_val = 10 [packed = true];
  int int64_val_size() const;
  void clear_int64_val();
  static const int kInt64ValFieldNumber = 10;
  ::google::protobuf::int64 int64_val(int index) const;
  void set_int64_val(int index, ::google::protobuf::int64 value);
  void add_int64_val(::google::protobuf::int64 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::int64 >&
      int64_val() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::int64 >*
      mutable_int64_val();

  // repeated bool bool_val = 11 [packed = true];
  int bool_val_size() const;
  void clear_bool_val();
  static const int kBoolValFieldNumber = 11;
  bool bool_val(int index) const;
  void set_bool_val(int index, bool value);
  void add_bool_val(bool value);
  const ::google::protobuf::RepeatedField< bool >&
      bool_val() const;
  ::google::protobuf::RepeatedField< bool >*
      mutable_bool_val();

  // repeated double dcomplex_val = 12 [packed = true];
  int dcomplex_val_size() const;
  void clear_dcomplex_val();
  static const int kDcomplexValFieldNumber = 12;
  double dcomplex_val(int index) const;
  void set_dcomplex_val(int index, double value);
  void add_dcomplex_val(double value);
  const ::google::protobuf::RepeatedField< double >&
      dcomplex_val() const;
  ::google::protobuf::RepeatedField< double >*
      mutable_dcomplex_val();

  // @@protoc_insertion_point(class_scope:tensorflow.TensorProto)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  friend class ::google::protobuf::Arena;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > half_val_;
  mutable int _half_val_cached_byte_size_;
  ::google::protobuf::RepeatedField< float > float_val_;
  mutable int _float_val_cached_byte_size_;
  ::google::protobuf::RepeatedField< double > double_val_;
  mutable int _double_val_cached_byte_size_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > int_val_;
  mutable int _int_val_cached_byte_size_;
  ::google::protobuf::RepeatedPtrField< ::std::string> string_val_;
  ::google::protobuf::RepeatedField< float > scomplex_val_;
  mutable int _scomplex_val_cached_byte_size_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int64 > int64_val_;
  mutable int _int64_val_cached_byte_size_;
  ::google::protobuf::RepeatedField< bool > bool_val_;
  mutable int _bool_val_cached_byte_size_;
  ::google::protobuf::RepeatedField< double > dcomplex_val_;
  mutable int _dcomplex_val_cached_byte_size_;
  ::google::protobuf::internal::ArenaStringPtr tensor_content_;
  ::tensorflow::TensorShapeProto* tensor_shape_;
  int dtype_;
  ::google::protobuf::int32 version_number_;
  mutable int _cached_size_;
  friend void  protobuf_InitDefaults_tensorboard_2eproto_impl();
  friend void  protobuf_AddDesc_tensorboard_2eproto_impl();
  friend void protobuf_AssignDesc_tensorboard_2eproto();
  friend void protobuf_ShutdownFile_tensorboard_2eproto();

  void InitAsDefaultInstance();
};
extern ::google::protobuf::internal::ExplicitlyConstructed<TensorProto> TensorProto_default_instance_;

// -------------------------------------------------------------------

class VersionDef : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:tensorflow.VersionDef) */ {
 public:
  VersionDef();
  virtual ~VersionDef();

  VersionDef(const VersionDef& from);

  inline VersionDef& operator=(const VersionDef& from) {
    CopyFrom(from);
    return *this;
  }

  inline ::google::protobuf::Arena* GetArena() const { return GetArenaNoVirtual(); }
  inline void* GetMaybeArenaPointer() const {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const VersionDef& default_instance();

  static const VersionDef* internal_default_instance();

  void UnsafeArenaSwap(VersionDef* other);
  void Swap(VersionDef* other);

  // implements Message ----------------------------------------------

  inline VersionDef* New() const { return New(NULL); }

  VersionDef* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const VersionDef& from);
  void MergeFrom(const VersionDef& from);
  void Clear();
  bool IsInitialized() const;

  size_t ByteSizeLong() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(VersionDef* other);
  void UnsafeMergeFrom(const VersionDef& from);
  protected:
  explicit VersionDef(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 producer = 1;
  void clear_producer();
  static const int kProducerFieldNumber = 1;
  ::google::protobuf::int32 producer() const;
  void set_producer(::google::protobuf::int32 value);

  // optional int32 min_consumer = 2;
  void clear_min_consumer();
  static const int kMinConsumerFieldNumber = 2;
  ::google::protobuf::int32 min_consumer() const;
  void set_min_consumer(::google::protobuf::int32 value);

  // repeated int32 bad_consumers = 3;
  int bad_consumers_size() const;
  void clear_bad_consumers();
  static const int kBadConsumersFieldNumber = 3;
  ::google::protobuf::int32 bad_consumers(int index) const;
  void set_bad_consumers(int index, ::google::protobuf::int32 value);
  void add_bad_consumers(::google::protobuf::int32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      bad_consumers() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_bad_consumers();

  // @@protoc_insertion_point(class_scope:tensorflow.VersionDef)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  friend class ::google::protobuf::Arena;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > bad_consumers_;
  mutable int _bad_consumers_cached_byte_size_;
  ::google::protobuf::int32 producer_;
  ::google::protobuf::int32 min_consumer_;
  mutable int _cached_size_;
  friend void  protobuf_InitDefaults_tensorboard_2eproto_impl();
  friend void  protobuf_AddDesc_tensorboard_2eproto_impl();
  friend void protobuf_AssignDesc_tensorboard_2eproto();
  friend void protobuf_ShutdownFile_tensorboard_2eproto();

  void InitAsDefaultInstance();
};
extern ::google::protobuf::internal::ExplicitlyConstructed<VersionDef> VersionDef_default_instance_;

// -------------------------------------------------------------------

class SummaryDescription : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:tensorflow.SummaryDescription) */ {
 public:
  SummaryDescription();
  virtual ~SummaryDescription();

  SummaryDescription(const SummaryDescription& from);

  inline SummaryDescription& operator=(const SummaryDescription& from) {
    CopyFrom(from);
    return *this;
  }

  inline ::google::protobuf::Arena* GetArena() const { return GetArenaNoVirtual(); }
  inline void* GetMaybeArenaPointer() const {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const SummaryDescription& default_instance();

  static const SummaryDescription* internal_default_instance();

  void UnsafeArenaSwap(SummaryDescription* other);
  void Swap(SummaryDescription* other);

  // implements Message ----------------------------------------------

  inline SummaryDescription* New() const { return New(NULL); }

  SummaryDescription* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SummaryDescription& from);
  void MergeFrom(const SummaryDescription& from);
  void Clear();
  bool IsInitialized() const;

  size_t ByteSizeLong() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(SummaryDescription* other);
  void UnsafeMergeFrom(const SummaryDescription& from);
  protected:
  explicit SummaryDescription(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string type_hint = 1;
  void clear_type_hint();
  static const int kTypeHintFieldNumber = 1;
  const ::std::string& type_hint() const;
  void set_type_hint(const ::std::string& value);
  void set_type_hint(const char* value);
  void set_type_hint(const char* value, size_t size);
  ::std::string* mutable_type_hint();
  ::std::string* release_type_hint();
  void set_allocated_type_hint(::std::string* type_hint);
  ::std::string* unsafe_arena_release_type_hint();
  void unsafe_arena_set_allocated_type_hint(
      ::std::string* type_hint);

  // @@protoc_insertion_point(class_scope:tensorflow.SummaryDescription)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  friend class ::google::protobuf::Arena;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::ArenaStringPtr type_hint_;
  mutable int _cached_size_;
  friend void  protobuf_InitDefaults_tensorboard_2eproto_impl();
  friend void  protobuf_AddDesc_tensorboard_2eproto_impl();
  friend void protobuf_AssignDesc_tensorboard_2eproto();
  friend void protobuf_ShutdownFile_tensorboard_2eproto();

  void InitAsDefaultInstance();
};
extern ::google::protobuf::internal::ExplicitlyConstructed<SummaryDescription> SummaryDescription_default_instance_;

// -------------------------------------------------------------------

class HistogramProto : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:tensorflow.HistogramProto) */ {
 public:
  HistogramProto();
  virtual ~HistogramProto();

  HistogramProto(const HistogramProto& from);

  inline HistogramProto& operator=(const HistogramProto& from) {
    CopyFrom(from);
    return *this;
  }

  inline ::google::protobuf::Arena* GetArena() const { return GetArenaNoVirtual(); }
  inline void* GetMaybeArenaPointer() const {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const HistogramProto& default_instance();

  static const HistogramProto* internal_default_instance();

  void UnsafeArenaSwap(HistogramProto* other);
  void Swap(HistogramProto* other);

  // implements Message ----------------------------------------------

  inline HistogramProto* New() const { return New(NULL); }

  HistogramProto* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const HistogramProto& from);
  void MergeFrom(const HistogramProto& from);
  void Clear();
  bool IsInitialized() const;

  size_t ByteSizeLong() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(HistogramProto* other);
  void UnsafeMergeFrom(const HistogramProto& from);
  protected:
  explicit HistogramProto(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional double min = 1;
  void clear_min();
  static const int kMinFieldNumber = 1;
  double min() const;
  void set_min(double value);

  // optional double max = 2;
  void clear_max();
  static const int kMaxFieldNumber = 2;
  double max() const;
  void set_max(double value);

  // optional double num = 3;
  void clear_num();
  static const int kNumFieldNumber = 3;
  double num() const;
  void set_num(double value);

  // optional double sum = 4;
  void clear_sum();
  static const int kSumFieldNumber = 4;
  double sum() const;
  void set_sum(double value);

  // optional double sum_squares = 5;
  void clear_sum_squares();
  static const int kSumSquaresFieldNumber = 5;
  double sum_squares() const;
  void set_sum_squares(double value);

  // repeated double bucket_limit = 6 [packed = true];
  int bucket_limit_size() const;
  void clear_bucket_limit();
  static const int kBucketLimitFieldNumber = 6;
  double bucket_limit(int index) const;
  void set_bucket_limit(int index, double value);
  void add_bucket_limit(double value);
  const ::google::protobuf::RepeatedField< double >&
      bucket_limit() const;
  ::google::protobuf::RepeatedField< double >*
      mutable_bucket_limit();

  // repeated double bucket = 7 [packed = true];
  int bucket_size() const;
  void clear_bucket();
  static const int kBucketFieldNumber = 7;
  double bucket(int index) const;
  void set_bucket(int index, double value);
  void add_bucket(double value);
  const ::google::protobuf::RepeatedField< double >&
      bucket() const;
  ::google::protobuf::RepeatedField< double >*
      mutable_bucket();

  // @@protoc_insertion_point(class_scope:tensorflow.HistogramProto)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  friend class ::google::protobuf::Arena;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::RepeatedField< double > bucket_limit_;
  mutable int _bucket_limit_cached_byte_size_;
  ::google::protobuf::RepeatedField< double > bucket_;
  mutable int _bucket_cached_byte_size_;
  double min_;
  double max_;
  double num_;
  double sum_;
  double sum_squares_;
  mutable int _cached_size_;
  friend void  protobuf_InitDefaults_tensorboard_2eproto_impl();
  friend void  protobuf_AddDesc_tensorboard_2eproto_impl();
  friend void protobuf_AssignDesc_tensorboard_2eproto();
  friend void protobuf_ShutdownFile_tensorboard_2eproto();

  void InitAsDefaultInstance();
};
extern ::google::protobuf::internal::ExplicitlyConstructed<HistogramProto> HistogramProto_default_instance_;

// -------------------------------------------------------------------

class Summary_Image : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:tensorflow.Summary.Image) */ {
 public:
  Summary_Image();
  virtual ~Summary_Image();

  Summary_Image(const Summary_Image& from);

  inline Summary_Image& operator=(const Summary_Image& from) {
    CopyFrom(from);
    return *this;
  }

  inline ::google::protobuf::Arena* GetArena() const { return GetArenaNoVirtual(); }
  inline void* GetMaybeArenaPointer() const {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const Summary_Image& default_instance();

  static const Summary_Image* internal_default_instance();

  void UnsafeArenaSwap(Summary_Image* other);
  void Swap(Summary_Image* other);

  // implements Message ----------------------------------------------

  inline Summary_Image* New() const { return New(NULL); }

  Summary_Image* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Summary_Image& from);
  void MergeFrom(const Summary_Image& from);
  void Clear();
  bool IsInitialized() const;

  size_t ByteSizeLong() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Summary_Image* other);
  void UnsafeMergeFrom(const Summary_Image& from);
  protected:
  explicit Summary_Image(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 height = 1;
  void clear_height();
  static const int kHeightFieldNumber = 1;
  ::google::protobuf::int32 height() const;
  void set_height(::google::protobuf::int32 value);

  // optional int32 width = 2;
  void clear_width();
  static const int kWidthFieldNumber = 2;
  ::google::protobuf::int32 width() const;
  void set_width(::google::protobuf::int32 value);

  // optional int32 colorspace = 3;
  void clear_colorspace();
  static const int kColorspaceFieldNumber = 3;
  ::google::protobuf::int32 colorspace() const;
  void set_colorspace(::google::protobuf::int32 value);

  // optional bytes encoded_image_string = 4;
  void clear_encoded_image_string();
  static const int kEncodedImageStringFieldNumber = 4;
  const ::std::string& encoded_image_string() const;
  void set_encoded_image_string(const ::std::string& value);
  void set_encoded_image_string(const char* value);
  void set_encoded_image_string(const void* value, size_t size);
  ::std::string* mutable_encoded_image_string();
  ::std::string* release_encoded_image_string();
  void set_allocated_encoded_image_string(::std::string* encoded_image_string);
  ::std::string* unsafe_arena_release_encoded_image_string();
  void unsafe_arena_set_allocated_encoded_image_string(
      ::std::string* encoded_image_string);

  // @@protoc_insertion_point(class_scope:tensorflow.Summary.Image)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  friend class ::google::protobuf::Arena;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::ArenaStringPtr encoded_image_string_;
  ::google::protobuf::int32 height_;
  ::google::protobuf::int32 width_;
  ::google::protobuf::int32 colorspace_;
  mutable int _cached_size_;
  friend void  protobuf_InitDefaults_tensorboard_2eproto_impl();
  friend void  protobuf_AddDesc_tensorboard_2eproto_impl();
  friend void protobuf_AssignDesc_tensorboard_2eproto();
  friend void protobuf_ShutdownFile_tensorboard_2eproto();

  void InitAsDefaultInstance();
};
extern ::google::protobuf::internal::ExplicitlyConstructed<Summary_Image> Summary_Image_default_instance_;

// -------------------------------------------------------------------

class Summary_Audio : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:tensorflow.Summary.Audio) */ {
 public:
  Summary_Audio();
  virtual ~Summary_Audio();

  Summary_Audio(const Summary_Audio& from);

  inline Summary_Audio& operator=(const Summary_Audio& from) {
    CopyFrom(from);
    return *this;
  }

  inline ::google::protobuf::Arena* GetArena() const { return GetArenaNoVirtual(); }
  inline void* GetMaybeArenaPointer() const {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const Summary_Audio& default_instance();

  static const Summary_Audio* internal_default_instance();

  void UnsafeArenaSwap(Summary_Audio* other);
  void Swap(Summary_Audio* other);

  // implements Message ----------------------------------------------

  inline Summary_Audio* New() const { return New(NULL); }

  Summary_Audio* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Summary_Audio& from);
  void MergeFrom(const Summary_Audio& from);
  void Clear();
  bool IsInitialized() const;

  size_t ByteSizeLong() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Summary_Audio* other);
  void UnsafeMergeFrom(const Summary_Audio& from);
  protected:
  explicit Summary_Audio(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional float sample_rate = 1;
  void clear_sample_rate();
  static const int kSampleRateFieldNumber = 1;
  float sample_rate() const;
  void set_sample_rate(float value);

  // optional int64 num_channels = 2;
  void clear_num_channels();
  static const int kNumChannelsFieldNumber = 2;
  ::google::protobuf::int64 num_channels() const;
  void set_num_channels(::google::protobuf::int64 value);

  // optional int64 length_frames = 3;
  void clear_length_frames();
  static const int kLengthFramesFieldNumber = 3;
  ::google::protobuf::int64 length_frames() const;
  void set_length_frames(::google::protobuf::int64 value);

  // optional bytes encoded_audio_string = 4;
  void clear_encoded_audio_string();
  static const int kEncodedAudioStringFieldNumber = 4;
  const ::std::string& encoded_audio_string() const;
  void set_encoded_audio_string(const ::std::string& value);
  void set_encoded_audio_string(const char* value);
  void set_encoded_audio_string(const void* value, size_t size);
  ::std::string* mutable_encoded_audio_string();
  ::std::string* release_encoded_audio_string();
  void set_allocated_encoded_audio_string(::std::string* encoded_audio_string);
  ::std::string* unsafe_arena_release_encoded_audio_string();
  void unsafe_arena_set_allocated_encoded_audio_string(
      ::std::string* encoded_audio_string);

  // optional string content_type = 5;
  void clear_content_type();
  static const int kContentTypeFieldNumber = 5;
  const ::std::string& content_type() const;
  void set_content_type(const ::std::string& value);
  void set_content_type(const char* value);
  void set_content_type(const char* value, size_t size);
  ::std::string* mutable_content_type();
  ::std::string* release_content_type();
  void set_allocated_content_type(::std::string* content_type);
  ::std::string* unsafe_arena_release_content_type();
  void unsafe_arena_set_allocated_content_type(
      ::std::string* content_type);

  // @@protoc_insertion_point(class_scope:tensorflow.Summary.Audio)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  friend class ::google::protobuf::Arena;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::ArenaStringPtr encoded_audio_string_;
  ::google::protobuf::internal::ArenaStringPtr content_type_;
  ::google::protobuf::int64 num_channels_;
  ::google::protobuf::int64 length_frames_;
  float sample_rate_;
  mutable int _cached_size_;
  friend void  protobuf_InitDefaults_tensorboard_2eproto_impl();
  friend void  protobuf_AddDesc_tensorboard_2eproto_impl();
  friend void protobuf_AssignDesc_tensorboard_2eproto();
  friend void protobuf_ShutdownFile_tensorboard_2eproto();

  void InitAsDefaultInstance();
};
extern ::google::protobuf::internal::ExplicitlyConstructed<Summary_Audio> Summary_Audio_default_instance_;

// -------------------------------------------------------------------

class Summary_Value : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:tensorflow.Summary.Value) */ {
 public:
  Summary_Value();
  virtual ~Summary_Value();

  Summary_Value(const Summary_Value& from);

  inline Summary_Value& operator=(const Summary_Value& from) {
    CopyFrom(from);
    return *this;
  }

  inline ::google::protobuf::Arena* GetArena() const { return GetArenaNoVirtual(); }
  inline void* GetMaybeArenaPointer() const {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const Summary_Value& default_instance();

  enum ValueCase {
    kSimpleValue = 2,
    kObsoleteOldStyleHistogram = 3,
    kImage = 4,
    kHisto = 5,
    kAudio = 6,
    kTensor = 8,
    VALUE_NOT_SET = 0,
  };

  static const Summary_Value* internal_default_instance();

  void UnsafeArenaSwap(Summary_Value* other);
  void Swap(Summary_Value* other);

  // implements Message ----------------------------------------------

  inline Summary_Value* New() const { return New(NULL); }

  Summary_Value* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Summary_Value& from);
  void MergeFrom(const Summary_Value& from);
  void Clear();
  bool IsInitialized() const;

  size_t ByteSizeLong() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Summary_Value* other);
  void UnsafeMergeFrom(const Summary_Value& from);
  protected:
  explicit Summary_Value(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string node_name = 7;
  void clear_node_name();
  static const int kNodeNameFieldNumber = 7;
  const ::std::string& node_name() const;
  void set_node_name(const ::std::string& value);
  void set_node_name(const char* value);
  void set_node_name(const char* value, size_t size);
  ::std::string* mutable_node_name();
  ::std::string* release_node_name();
  void set_allocated_node_name(::std::string* node_name);
  ::std::string* unsafe_arena_release_node_name();
  void unsafe_arena_set_allocated_node_name(
      ::std::string* node_name);

  // optional string tag = 1;
  void clear_tag();
  static const int kTagFieldNumber = 1;
  const ::std::string& tag() const;
  void set_tag(const ::std::string& value);
  void set_tag(const char* value);
  void set_tag(const char* value, size_t size);
  ::std::string* mutable_tag();
  ::std::string* release_tag();
  void set_allocated_tag(::std::string* tag);
  ::std::string* unsafe_arena_release_tag();
  void unsafe_arena_set_allocated_tag(
      ::std::string* tag);

  // optional float simple_value = 2;
  private:
  bool has_simple_value() const;
  public:
  void clear_simple_value();
  static const int kSimpleValueFieldNumber = 2;
  float simple_value() const;
  void set_simple_value(float value);

  // optional bytes obsolete_old_style_histogram = 3;
  private:
  bool has_obsolete_old_style_histogram() const;
  public:
  void clear_obsolete_old_style_histogram();
  static const int kObsoleteOldStyleHistogramFieldNumber = 3;
  const ::std::string& obsolete_old_style_histogram() const;
  void set_obsolete_old_style_histogram(const ::std::string& value);
  void set_obsolete_old_style_histogram(const char* value);
  void set_obsolete_old_style_histogram(const void* value, size_t size);
  ::std::string* mutable_obsolete_old_style_histogram();
  ::std::string* release_obsolete_old_style_histogram();
  void set_allocated_obsolete_old_style_histogram(::std::string* obsolete_old_style_histogram);
  ::std::string* unsafe_arena_release_obsolete_old_style_histogram();
  void unsafe_arena_set_allocated_obsolete_old_style_histogram(
      ::std::string* obsolete_old_style_histogram);

  // optional .tensorflow.Summary.Image image = 4;
  bool has_image() const;
  void clear_image();
  static const int kImageFieldNumber = 4;
  private:
  void _slow_mutable_image();
  void _slow_set_allocated_image(
      ::google::protobuf::Arena* message_arena, ::tensorflow::Summary_Image** image);
  ::tensorflow::Summary_Image* _slow_release_image();
  public:
  const ::tensorflow::Summary_Image& image() const;
  ::tensorflow::Summary_Image* mutable_image();
  ::tensorflow::Summary_Image* release_image();
  void set_allocated_image(::tensorflow::Summary_Image* image);
  ::tensorflow::Summary_Image* unsafe_arena_release_image();
  void unsafe_arena_set_allocated_image(
      ::tensorflow::Summary_Image* image);

  // optional .tensorflow.HistogramProto histo = 5;
  bool has_histo() const;
  void clear_histo();
  static const int kHistoFieldNumber = 5;
  private:
  void _slow_mutable_histo();
  void _slow_set_allocated_histo(
      ::google::protobuf::Arena* message_arena, ::tensorflow::HistogramProto** histo);
  ::tensorflow::HistogramProto* _slow_release_histo();
  public:
  const ::tensorflow::HistogramProto& histo() const;
  ::tensorflow::HistogramProto* mutable_histo();
  ::tensorflow::HistogramProto* release_histo();
  void set_allocated_histo(::tensorflow::HistogramProto* histo);
  ::tensorflow::HistogramProto* unsafe_arena_release_histo();
  void unsafe_arena_set_allocated_histo(
      ::tensorflow::HistogramProto* histo);

  // optional .tensorflow.Summary.Audio audio = 6;
  bool has_audio() const;
  void clear_audio();
  static const int kAudioFieldNumber = 6;
  private:
  void _slow_mutable_audio();
  void _slow_set_allocated_audio(
      ::google::protobuf::Arena* message_arena, ::tensorflow::Summary_Audio** audio);
  ::tensorflow::Summary_Audio* _slow_release_audio();
  public:
  const ::tensorflow::Summary_Audio& audio() const;
  ::tensorflow::Summary_Audio* mutable_audio();
  ::tensorflow::Summary_Audio* release_audio();
  void set_allocated_audio(::tensorflow::Summary_Audio* audio);
  ::tensorflow::Summary_Audio* unsafe_arena_release_audio();
  void unsafe_arena_set_allocated_audio(
      ::tensorflow::Summary_Audio* audio);

  // optional .tensorflow.TensorProto tensor = 8;
  bool has_tensor() const;
  void clear_tensor();
  static const int kTensorFieldNumber = 8;
  private:
  void _slow_mutable_tensor();
  void _slow_set_allocated_tensor(
      ::google::protobuf::Arena* message_arena, ::tensorflow::TensorProto** tensor);
  ::tensorflow::TensorProto* _slow_release_tensor();
  public:
  const ::tensorflow::TensorProto& tensor() const;
  ::tensorflow::TensorProto* mutable_tensor();
  ::tensorflow::TensorProto* release_tensor();
  void set_allocated_tensor(::tensorflow::TensorProto* tensor);
  ::tensorflow::TensorProto* unsafe_arena_release_tensor();
  void unsafe_arena_set_allocated_tensor(
      ::tensorflow::TensorProto* tensor);

  ValueCase value_case() const;
  // @@protoc_insertion_point(class_scope:tensorflow.Summary.Value)
 private:
  inline void set_has_simple_value();
  inline void set_has_obsolete_old_style_histogram();
  inline void set_has_image();
  inline void set_has_histo();
  inline void set_has_audio();
  inline void set_has_tensor();

  inline bool has_value() const;
  void clear_value();
  inline void clear_has_value();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  friend class ::google::protobuf::Arena;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::ArenaStringPtr node_name_;
  ::google::protobuf::internal::ArenaStringPtr tag_;
  union ValueUnion {
    ValueUnion() {}
    float simple_value_;
    ::google::protobuf::internal::ArenaStringPtr obsolete_old_style_histogram_;
    ::tensorflow::Summary_Image* image_;
    ::tensorflow::HistogramProto* histo_;
    ::tensorflow::Summary_Audio* audio_;
    ::tensorflow::TensorProto* tensor_;
  } value_;
  mutable int _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend void  protobuf_InitDefaults_tensorboard_2eproto_impl();
  friend void  protobuf_AddDesc_tensorboard_2eproto_impl();
  friend void protobuf_AssignDesc_tensorboard_2eproto();
  friend void protobuf_ShutdownFile_tensorboard_2eproto();

  void InitAsDefaultInstance();
};
extern ::google::protobuf::internal::ExplicitlyConstructed<Summary_Value> Summary_Value_default_instance_;

// -------------------------------------------------------------------

class Summary : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:tensorflow.Summary) */ {
 public:
  Summary();
  virtual ~Summary();

  Summary(const Summary& from);

  inline Summary& operator=(const Summary& from) {
    CopyFrom(from);
    return *this;
  }

  inline ::google::protobuf::Arena* GetArena() const { return GetArenaNoVirtual(); }
  inline void* GetMaybeArenaPointer() const {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const Summary& default_instance();

  static const Summary* internal_default_instance();

  void UnsafeArenaSwap(Summary* other);
  void Swap(Summary* other);

  // implements Message ----------------------------------------------

  inline Summary* New() const { return New(NULL); }

  Summary* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Summary& from);
  void MergeFrom(const Summary& from);
  void Clear();
  bool IsInitialized() const;

  size_t ByteSizeLong() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Summary* other);
  void UnsafeMergeFrom(const Summary& from);
  protected:
  explicit Summary(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef Summary_Image Image;
  typedef Summary_Audio Audio;
  typedef Summary_Value Value;

  // accessors -------------------------------------------------------

  // repeated .tensorflow.Summary.Value value = 1;
  int value_size() const;
  void clear_value();
  static const int kValueFieldNumber = 1;
  const ::tensorflow::Summary_Value& value(int index) const;
  ::tensorflow::Summary_Value* mutable_value(int index);
  ::tensorflow::Summary_Value* add_value();
  ::google::protobuf::RepeatedPtrField< ::tensorflow::Summary_Value >*
      mutable_value();
  const ::google::protobuf::RepeatedPtrField< ::tensorflow::Summary_Value >&
      value() const;

  // @@protoc_insertion_point(class_scope:tensorflow.Summary)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  friend class ::google::protobuf::Arena;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::RepeatedPtrField< ::tensorflow::Summary_Value > value_;
  mutable int _cached_size_;
  friend void  protobuf_InitDefaults_tensorboard_2eproto_impl();
  friend void  protobuf_AddDesc_tensorboard_2eproto_impl();
  friend void protobuf_AssignDesc_tensorboard_2eproto();
  friend void protobuf_ShutdownFile_tensorboard_2eproto();

  void InitAsDefaultInstance();
};
extern ::google::protobuf::internal::ExplicitlyConstructed<Summary> Summary_default_instance_;

// -------------------------------------------------------------------

class AttrValue_ListValue : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:tensorflow.AttrValue.ListValue) */ {
 public:
  AttrValue_ListValue();
  virtual ~AttrValue_ListValue();

  AttrValue_ListValue(const AttrValue_ListValue& from);

  inline AttrValue_ListValue& operator=(const AttrValue_ListValue& from) {
    CopyFrom(from);
    return *this;
  }

  inline ::google::protobuf::Arena* GetArena() const { return GetArenaNoVirtual(); }
  inline void* GetMaybeArenaPointer() const {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const AttrValue_ListValue& default_instance();

  static const AttrValue_ListValue* internal_default_instance();

  void UnsafeArenaSwap(AttrValue_ListValue* other);
  void Swap(AttrValue_ListValue* other);

  // implements Message ----------------------------------------------

  inline AttrValue_ListValue* New() const { return New(NULL); }

  AttrValue_ListValue* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AttrValue_ListValue& from);
  void MergeFrom(const AttrValue_ListValue& from);
  void Clear();
  bool IsInitialized() const;

  size_t ByteSizeLong() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(AttrValue_ListValue* other);
  void UnsafeMergeFrom(const AttrValue_ListValue& from);
  protected:
  explicit AttrValue_ListValue(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated bytes s = 2;
  int s_size() const;
  void clear_s();
  static const int kSFieldNumber = 2;
  const ::std::string& s(int index) const;
  ::std::string* mutable_s(int index);
  void set_s(int index, const ::std::string& value);
  void set_s(int index, const char* value);
  void set_s(int index, const void* value, size_t size);
  ::std::string* add_s();
  void add_s(const ::std::string& value);
  void add_s(const char* value);
  void add_s(const void* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& s() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_s();

  // repeated int64 i = 3 [packed = true];
  int i_size() const;
  void clear_i();
  static const int kIFieldNumber = 3;
  ::google::protobuf::int64 i(int index) const;
  void set_i(int index, ::google::protobuf::int64 value);
  void add_i(::google::protobuf::int64 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::int64 >&
      i() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::int64 >*
      mutable_i();

  // repeated float f = 4 [packed = true];
  int f_size() const;
  void clear_f();
  static const int kFFieldNumber = 4;
  float f(int index) const;
  void set_f(int index, float value);
  void add_f(float value);
  const ::google::protobuf::RepeatedField< float >&
      f() const;
  ::google::protobuf::RepeatedField< float >*
      mutable_f();

  // repeated bool b = 5 [packed = true];
  int b_size() const;
  void clear_b();
  static const int kBFieldNumber = 5;
  bool b(int index) const;
  void set_b(int index, bool value);
  void add_b(bool value);
  const ::google::protobuf::RepeatedField< bool >&
      b() const;
  ::google::protobuf::RepeatedField< bool >*
      mutable_b();

  // repeated .tensorflow.DataType type = 6 [packed = true];
  int type_size() const;
  void clear_type();
  static const int kTypeFieldNumber = 6;
  ::tensorflow::DataType type(int index) const;
  void set_type(int index, ::tensorflow::DataType value);
  void add_type(::tensorflow::DataType value);
  const ::google::protobuf::RepeatedField<int>& type() const;
  ::google::protobuf::RepeatedField<int>* mutable_type();

  // repeated .tensorflow.TensorShapeProto shape = 7;
  int shape_size() const;
  void clear_shape();
  static const int kShapeFieldNumber = 7;
  const ::tensorflow::TensorShapeProto& shape(int index) const;
  ::tensorflow::TensorShapeProto* mutable_shape(int index);
  ::tensorflow::TensorShapeProto* add_shape();
  ::google::protobuf::RepeatedPtrField< ::tensorflow::TensorShapeProto >*
      mutable_shape();
  const ::google::protobuf::RepeatedPtrField< ::tensorflow::TensorShapeProto >&
      shape() const;

  // repeated .tensorflow.TensorProto tensor = 8;
  int tensor_size() const;
  void clear_tensor();
  static const int kTensorFieldNumber = 8;
  const ::tensorflow::TensorProto& tensor(int index) const;
  ::tensorflow::TensorProto* mutable_tensor(int index);
  ::tensorflow::TensorProto* add_tensor();
  ::google::protobuf::RepeatedPtrField< ::tensorflow::TensorProto >*
      mutable_tensor();
  const ::google::protobuf::RepeatedPtrField< ::tensorflow::TensorProto >&
      tensor() const;

  // @@protoc_insertion_point(class_scope:tensorflow.AttrValue.ListValue)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  friend class ::google::protobuf::Arena;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::RepeatedPtrField< ::std::string> s_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int64 > i_;
  mutable int _i_cached_byte_size_;
  ::google::protobuf::RepeatedField< float > f_;
  mutable int _f_cached_byte_size_;
  ::google::protobuf::RepeatedField< bool > b_;
  mutable int _b_cached_byte_size_;
  ::google::protobuf::RepeatedField<int> type_;
  mutable int _type_cached_byte_size_;
  ::google::protobuf::RepeatedPtrField< ::tensorflow::TensorShapeProto > shape_;
  ::google::protobuf::RepeatedPtrField< ::tensorflow::TensorProto > tensor_;
  mutable int _cached_size_;
  friend void  protobuf_InitDefaults_tensorboard_2eproto_impl();
  friend void  protobuf_AddDesc_tensorboard_2eproto_impl();
  friend void protobuf_AssignDesc_tensorboard_2eproto();
  friend void protobuf_ShutdownFile_tensorboard_2eproto();

  void InitAsDefaultInstance();
};
extern ::google::protobuf::internal::ExplicitlyConstructed<AttrValue_ListValue> AttrValue_ListValue_default_instance_;

// -------------------------------------------------------------------

class AttrValue : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:tensorflow.AttrValue) */ {
 public:
  AttrValue();
  virtual ~AttrValue();

  AttrValue(const AttrValue& from);

  inline AttrValue& operator=(const AttrValue& from) {
    CopyFrom(from);
    return *this;
  }

  inline ::google::protobuf::Arena* GetArena() const { return GetArenaNoVirtual(); }
  inline void* GetMaybeArenaPointer() const {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const AttrValue& default_instance();

  enum ValueCase {
    kS = 2,
    kI = 3,
    kF = 4,
    kB = 5,
    kType = 6,
    kShape = 7,
    kTensor = 8,
    kList = 1,
    kFunc = 10,
    kPlaceholder = 9,
    VALUE_NOT_SET = 0,
  };

  static const AttrValue* internal_default_instance();

  void UnsafeArenaSwap(AttrValue* other);
  void Swap(AttrValue* other);

  // implements Message ----------------------------------------------

  inline AttrValue* New() const { return New(NULL); }

  AttrValue* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AttrValue& from);
  void MergeFrom(const AttrValue& from);
  void Clear();
  bool IsInitialized() const;

  size_t ByteSizeLong() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(AttrValue* other);
  void UnsafeMergeFrom(const AttrValue& from);
  protected:
  explicit AttrValue(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef AttrValue_ListValue ListValue;

  // accessors -------------------------------------------------------

  // optional bytes s = 2;
  private:
  bool has_s() const;
  public:
  void clear_s();
  static const int kSFieldNumber = 2;
  const ::std::string& s() const;
  void set_s(const ::std::string& value);
  void set_s(const char* value);
  void set_s(const void* value, size_t size);
  ::std::string* mutable_s();
  ::std::string* release_s();
  void set_allocated_s(::std::string* s);
  ::std::string* unsafe_arena_release_s();
  void unsafe_arena_set_allocated_s(
      ::std::string* s);

  // optional int64 i = 3;
  private:
  bool has_i() const;
  public:
  void clear_i();
  static const int kIFieldNumber = 3;
  ::google::protobuf::int64 i() const;
  void set_i(::google::protobuf::int64 value);

  // optional float f = 4;
  private:
  bool has_f() const;
  public:
  void clear_f();
  static const int kFFieldNumber = 4;
  float f() const;
  void set_f(float value);

  // optional bool b = 5;
  private:
  bool has_b() const;
  public:
  void clear_b();
  static const int kBFieldNumber = 5;
  bool b() const;
  void set_b(bool value);

  // optional .tensorflow.DataType type = 6;
  private:
  bool has_type() const;
  public:
  void clear_type();
  static const int kTypeFieldNumber = 6;
  ::tensorflow::DataType type() const;
  void set_type(::tensorflow::DataType value);

  // optional .tensorflow.TensorShapeProto shape = 7;
  bool has_shape() const;
  void clear_shape();
  static const int kShapeFieldNumber = 7;
  private:
  void _slow_mutable_shape();
  void _slow_set_allocated_shape(
      ::google::protobuf::Arena* message_arena, ::tensorflow::TensorShapeProto** shape);
  ::tensorflow::TensorShapeProto* _slow_release_shape();
  public:
  const ::tensorflow::TensorShapeProto& shape() const;
  ::tensorflow::TensorShapeProto* mutable_shape();
  ::tensorflow::TensorShapeProto* release_shape();
  void set_allocated_shape(::tensorflow::TensorShapeProto* shape);
  ::tensorflow::TensorShapeProto* unsafe_arena_release_shape();
  void unsafe_arena_set_allocated_shape(
      ::tensorflow::TensorShapeProto* shape);

  // optional .tensorflow.TensorProto tensor = 8;
  bool has_tensor() const;
  void clear_tensor();
  static const int kTensorFieldNumber = 8;
  private:
  void _slow_mutable_tensor();
  void _slow_set_allocated_tensor(
      ::google::protobuf::Arena* message_arena, ::tensorflow::TensorProto** tensor);
  ::tensorflow::TensorProto* _slow_release_tensor();
  public:
  const ::tensorflow::TensorProto& tensor() const;
  ::tensorflow::TensorProto* mutable_tensor();
  ::tensorflow::TensorProto* release_tensor();
  void set_allocated_tensor(::tensorflow::TensorProto* tensor);
  ::tensorflow::TensorProto* unsafe_arena_release_tensor();
  void unsafe_arena_set_allocated_tensor(
      ::tensorflow::TensorProto* tensor);

  // optional .tensorflow.AttrValue.ListValue list = 1;
  bool has_list() const;
  void clear_list();
  static const int kListFieldNumber = 1;
  private:
  void _slow_mutable_list();
  void _slow_set_allocated_list(
      ::google::protobuf::Arena* message_arena, ::tensorflow::AttrValue_ListValue** list);
  ::tensorflow::AttrValue_ListValue* _slow_release_list();
  public:
  const ::tensorflow::AttrValue_ListValue& list() const;
  ::tensorflow::AttrValue_ListValue* mutable_list();
  ::tensorflow::AttrValue_ListValue* release_list();
  void set_allocated_list(::tensorflow::AttrValue_ListValue* list);
  ::tensorflow::AttrValue_ListValue* unsafe_arena_release_list();
  void unsafe_arena_set_allocated_list(
      ::tensorflow::AttrValue_ListValue* list);

  // optional .tensorflow.NameAttrList func = 10;
  bool has_func() const;
  void clear_func();
  static const int kFuncFieldNumber = 10;
  private:
  void _slow_mutable_func();
  void _slow_set_allocated_func(
      ::google::protobuf::Arena* message_arena, ::tensorflow::NameAttrList** func);
  ::tensorflow::NameAttrList* _slow_release_func();
  public:
  const ::tensorflow::NameAttrList& func() const;
  ::tensorflow::NameAttrList* mutable_func();
  ::tensorflow::NameAttrList* release_func();
  void set_allocated_func(::tensorflow::NameAttrList* func);
  ::tensorflow::NameAttrList* unsafe_arena_release_func();
  void unsafe_arena_set_allocated_func(
      ::tensorflow::NameAttrList* func);

  // optional string placeholder = 9;
  private:
  bool has_placeholder() const;
  public:
  void clear_placeholder();
  static const int kPlaceholderFieldNumber = 9;
  const ::std::string& placeholder() const;
  void set_placeholder(const ::std::string& value);
  void set_placeholder(const char* value);
  void set_placeholder(const char* value, size_t size);
  ::std::string* mutable_placeholder();
  ::std::string* release_placeholder();
  void set_allocated_placeholder(::std::string* placeholder);
  ::std::string* unsafe_arena_release_placeholder();
  void unsafe_arena_set_allocated_placeholder(
      ::std::string* placeholder);

  ValueCase value_case() const;
  // @@protoc_insertion_point(class_scope:tensorflow.AttrValue)
 private:
  inline void set_has_s();
  inline void set_has_i();
  inline void set_has_f();
  inline void set_has_b();
  inline void set_has_type();
  inline void set_has_shape();
  inline void set_has_tensor();
  inline void set_has_list();
  inline void set_has_func();
  inline void set_has_placeholder();

  inline bool has_value() const;
  void clear_value();
  inline void clear_has_value();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  friend class ::google::protobuf::Arena;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  union ValueUnion {
    ValueUnion() {}
    ::google::protobuf::internal::ArenaStringPtr s_;
    ::google::protobuf::int64 i_;
    float f_;
    bool b_;
    int type_;
    ::tensorflow::TensorShapeProto* shape_;
    ::tensorflow::TensorProto* tensor_;
    ::tensorflow::AttrValue_ListValue* list_;
    ::tensorflow::NameAttrList* func_;
    ::google::protobuf::internal::ArenaStringPtr placeholder_;
  } value_;
  mutable int _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend void  protobuf_InitDefaults_tensorboard_2eproto_impl();
  friend void  protobuf_AddDesc_tensorboard_2eproto_impl();
  friend void protobuf_AssignDesc_tensorboard_2eproto();
  friend void protobuf_ShutdownFile_tensorboard_2eproto();

  void InitAsDefaultInstance();
};
extern ::google::protobuf::internal::ExplicitlyConstructed<AttrValue> AttrValue_default_instance_;

// -------------------------------------------------------------------

class NameAttrList : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:tensorflow.NameAttrList) */ {
 public:
  NameAttrList();
  virtual ~NameAttrList();

  NameAttrList(const NameAttrList& from);

  inline NameAttrList& operator=(const NameAttrList& from) {
    CopyFrom(from);
    return *this;
  }

  inline ::google::protobuf::Arena* GetArena() const { return GetArenaNoVirtual(); }
  inline void* GetMaybeArenaPointer() const {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const NameAttrList& default_instance();

  static const NameAttrList* internal_default_instance();

  void UnsafeArenaSwap(NameAttrList* other);
  void Swap(NameAttrList* other);

  // implements Message ----------------------------------------------

  inline NameAttrList* New() const { return New(NULL); }

  NameAttrList* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const NameAttrList& from);
  void MergeFrom(const NameAttrList& from);
  void Clear();
  bool IsInitialized() const;

  size_t ByteSizeLong() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(NameAttrList* other);
  void UnsafeMergeFrom(const NameAttrList& from);
  protected:
  explicit NameAttrList(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  // optional string name = 1;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);
  ::std::string* unsafe_arena_release_name();
  void unsafe_arena_set_allocated_name(
      ::std::string* name);

  // map<string, .tensorflow.AttrValue> attr = 2;
  int attr_size() const;
  void clear_attr();
  static const int kAttrFieldNumber = 2;
  const ::google::protobuf::Map< ::std::string, ::tensorflow::AttrValue >&
      attr() const;
  ::google::protobuf::Map< ::std::string, ::tensorflow::AttrValue >*
      mutable_attr();

  // @@protoc_insertion_point(class_scope:tensorflow.NameAttrList)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  friend class ::google::protobuf::Arena;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  typedef ::google::protobuf::internal::MapEntryLite<
      ::std::string, ::tensorflow::AttrValue,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE,
      0 >
      NameAttrList_AttrEntry;
  ::google::protobuf::internal::MapField<
      ::std::string, ::tensorflow::AttrValue,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE,
      0 > attr_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  mutable int _cached_size_;
  friend void  protobuf_InitDefaults_tensorboard_2eproto_impl();
  friend void  protobuf_AddDesc_tensorboard_2eproto_impl();
  friend void protobuf_AssignDesc_tensorboard_2eproto();
  friend void protobuf_ShutdownFile_tensorboard_2eproto();

  void InitAsDefaultInstance();
};
extern ::google::protobuf::internal::ExplicitlyConstructed<NameAttrList> NameAttrList_default_instance_;

// -------------------------------------------------------------------

class NodeDef : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:tensorflow.NodeDef) */ {
 public:
  NodeDef();
  virtual ~NodeDef();

  NodeDef(const NodeDef& from);

  inline NodeDef& operator=(const NodeDef& from) {
    CopyFrom(from);
    return *this;
  }

  inline ::google::protobuf::Arena* GetArena() const { return GetArenaNoVirtual(); }
  inline void* GetMaybeArenaPointer() const {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const NodeDef& default_instance();

  static const NodeDef* internal_default_instance();

  void UnsafeArenaSwap(NodeDef* other);
  void Swap(NodeDef* other);

  // implements Message ----------------------------------------------

  inline NodeDef* New() const { return New(NULL); }

  NodeDef* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const NodeDef& from);
  void MergeFrom(const NodeDef& from);
  void Clear();
  bool IsInitialized() const;

  size_t ByteSizeLong() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(NodeDef* other);
  void UnsafeMergeFrom(const NodeDef& from);
  protected:
  explicit NodeDef(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  // optional string name = 1;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);
  ::std::string* unsafe_arena_release_name();
  void unsafe_arena_set_allocated_name(
      ::std::string* name);

  // optional string op = 2;
  void clear_op();
  static const int kOpFieldNumber = 2;
  const ::std::string& op() const;
  void set_op(const ::std::string& value);
  void set_op(const char* value);
  void set_op(const char* value, size_t size);
  ::std::string* mutable_op();
  ::std::string* release_op();
  void set_allocated_op(::std::string* op);
  ::std::string* unsafe_arena_release_op();
  void unsafe_arena_set_allocated_op(
      ::std::string* op);

  // repeated string input = 3;
  int input_size() const;
  void clear_input();
  static const int kInputFieldNumber = 3;
  const ::std::string& input(int index) const;
  ::std::string* mutable_input(int index);
  void set_input(int index, const ::std::string& value);
  void set_input(int index, const char* value);
  void set_input(int index, const char* value, size_t size);
  ::std::string* add_input();
  void add_input(const ::std::string& value);
  void add_input(const char* value);
  void add_input(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& input() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_input();

  // optional string device = 4;
  void clear_device();
  static const int kDeviceFieldNumber = 4;
  const ::std::string& device() const;
  void set_device(const ::std::string& value);
  void set_device(const char* value);
  void set_device(const char* value, size_t size);
  ::std::string* mutable_device();
  ::std::string* release_device();
  void set_allocated_device(::std::string* device);
  ::std::string* unsafe_arena_release_device();
  void unsafe_arena_set_allocated_device(
      ::std::string* device);

  // map<string, .tensorflow.AttrValue> attr = 5;
  int attr_size() const;
  void clear_attr();
  static const int kAttrFieldNumber = 5;
  const ::google::protobuf::Map< ::std::string, ::tensorflow::AttrValue >&
      attr() const;
  ::google::protobuf::Map< ::std::string, ::tensorflow::AttrValue >*
      mutable_attr();

  // @@protoc_insertion_point(class_scope:tensorflow.NodeDef)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  friend class ::google::protobuf::Arena;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::RepeatedPtrField< ::std::string> input_;
  typedef ::google::protobuf::internal::MapEntryLite<
      ::std::string, ::tensorflow::AttrValue,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE,
      0 >
      NodeDef_AttrEntry;
  ::google::protobuf::internal::MapField<
      ::std::string, ::tensorflow::AttrValue,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE,
      0 > attr_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::internal::ArenaStringPtr op_;
  ::google::protobuf::internal::ArenaStringPtr device_;
  mutable int _cached_size_;
  friend void  protobuf_InitDefaults_tensorboard_2eproto_impl();
  friend void  protobuf_AddDesc_tensorboard_2eproto_impl();
  friend void protobuf_AssignDesc_tensorboard_2eproto();
  friend void protobuf_ShutdownFile_tensorboard_2eproto();

  void InitAsDefaultInstance();
};
extern ::google::protobuf::internal::ExplicitlyConstructed<NodeDef> NodeDef_default_instance_;

// -------------------------------------------------------------------

class GraphDef : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:tensorflow.GraphDef) */ {
 public:
  GraphDef();
  virtual ~GraphDef();

  GraphDef(const GraphDef& from);

  inline GraphDef& operator=(const GraphDef& from) {
    CopyFrom(from);
    return *this;
  }

  inline ::google::protobuf::Arena* GetArena() const { return GetArenaNoVirtual(); }
  inline void* GetMaybeArenaPointer() const {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const GraphDef& default_instance();

  static const GraphDef* internal_default_instance();

  void UnsafeArenaSwap(GraphDef* other);
  void Swap(GraphDef* other);

  // implements Message ----------------------------------------------

  inline GraphDef* New() const { return New(NULL); }

  GraphDef* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GraphDef& from);
  void MergeFrom(const GraphDef& from);
  void Clear();
  bool IsInitialized() const;

  size_t ByteSizeLong() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(GraphDef* other);
  void UnsafeMergeFrom(const GraphDef& from);
  protected:
  explicit GraphDef(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .tensorflow.NodeDef node = 1;
  int node_size() const;
  void clear_node();
  static const int kNodeFieldNumber = 1;
  const ::tensorflow::NodeDef& node(int index) const;
  ::tensorflow::NodeDef* mutable_node(int index);
  ::tensorflow::NodeDef* add_node();
  ::google::protobuf::RepeatedPtrField< ::tensorflow::NodeDef >*
      mutable_node();
  const ::google::protobuf::RepeatedPtrField< ::tensorflow::NodeDef >&
      node() const;

  // optional .tensorflow.VersionDef versions = 4;
  bool has_versions() const;
  void clear_versions();
  static const int kVersionsFieldNumber = 4;
  private:
  void _slow_mutable_versions();
  void _slow_set_allocated_versions(
      ::google::protobuf::Arena* message_arena, ::tensorflow::VersionDef** versions);
  ::tensorflow::VersionDef* _slow_release_versions();
  public:
  const ::tensorflow::VersionDef& versions() const;
  ::tensorflow::VersionDef* mutable_versions();
  ::tensorflow::VersionDef* release_versions();
  void set_allocated_versions(::tensorflow::VersionDef* versions);
  ::tensorflow::VersionDef* unsafe_arena_release_versions();
  void unsafe_arena_set_allocated_versions(
      ::tensorflow::VersionDef* versions);

  // optional int32 version = 3 [deprecated = true];
  GOOGLE_PROTOBUF_DEPRECATED_ATTR void clear_version();
  GOOGLE_PROTOBUF_DEPRECATED_ATTR static const int kVersionFieldNumber = 3;
  GOOGLE_PROTOBUF_DEPRECATED_ATTR ::google::protobuf::int32 version() const;
  GOOGLE_PROTOBUF_DEPRECATED_ATTR void set_version(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:tensorflow.GraphDef)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  friend class ::google::protobuf::Arena;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::RepeatedPtrField< ::tensorflow::NodeDef > node_;
  ::tensorflow::VersionDef* versions_;
  ::google::protobuf::int32 version_;
  mutable int _cached_size_;
  friend void  protobuf_InitDefaults_tensorboard_2eproto_impl();
  friend void  protobuf_AddDesc_tensorboard_2eproto_impl();
  friend void protobuf_AssignDesc_tensorboard_2eproto();
  friend void protobuf_ShutdownFile_tensorboard_2eproto();

  void InitAsDefaultInstance();
};
extern ::google::protobuf::internal::ExplicitlyConstructed<GraphDef> GraphDef_default_instance_;

// -------------------------------------------------------------------

class Event : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:tensorflow.Event) */ {
 public:
  Event();
  virtual ~Event();

  Event(const Event& from);

  inline Event& operator=(const Event& from) {
    CopyFrom(from);
    return *this;
  }

  inline ::google::protobuf::Arena* GetArena() const { return GetArenaNoVirtual(); }
  inline void* GetMaybeArenaPointer() const {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const Event& default_instance();

  enum WhatCase {
    kFileVersion = 3,
    kGraphDef = 4,
    kSummary = 5,
    kLogMessage = 6,
    kSessionLog = 7,
    kTaggedRunMetadata = 8,
    kMetaGraphDef = 9,
    WHAT_NOT_SET = 0,
  };

  static const Event* internal_default_instance();

  void UnsafeArenaSwap(Event* other);
  void Swap(Event* other);

  // implements Message ----------------------------------------------

  inline Event* New() const { return New(NULL); }

  Event* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Event& from);
  void MergeFrom(const Event& from);
  void Clear();
  bool IsInitialized() const;

  size_t ByteSizeLong() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Event* other);
  void UnsafeMergeFrom(const Event& from);
  protected:
  explicit Event(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional double wall_time = 1;
  void clear_wall_time();
  static const int kWallTimeFieldNumber = 1;
  double wall_time() const;
  void set_wall_time(double value);

  // optional int64 step = 2;
  void clear_step();
  static const int kStepFieldNumber = 2;
  ::google::protobuf::int64 step() const;
  void set_step(::google::protobuf::int64 value);

  // optional string file_version = 3;
  private:
  bool has_file_version() const;
  public:
  void clear_file_version();
  static const int kFileVersionFieldNumber = 3;
  const ::std::string& file_version() const;
  void set_file_version(const ::std::string& value);
  void set_file_version(const char* value);
  void set_file_version(const char* value, size_t size);
  ::std::string* mutable_file_version();
  ::std::string* release_file_version();
  void set_allocated_file_version(::std::string* file_version);
  ::std::string* unsafe_arena_release_file_version();
  void unsafe_arena_set_allocated_file_version(
      ::std::string* file_version);

  // optional bytes graph_def = 4;
  private:
  bool has_graph_def() const;
  public:
  void clear_graph_def();
  static const int kGraphDefFieldNumber = 4;
  const ::std::string& graph_def() const;
  void set_graph_def(const ::std::string& value);
  void set_graph_def(const char* value);
  void set_graph_def(const void* value, size_t size);
  ::std::string* mutable_graph_def();
  ::std::string* release_graph_def();
  void set_allocated_graph_def(::std::string* graph_def);
  ::std::string* unsafe_arena_release_graph_def();
  void unsafe_arena_set_allocated_graph_def(
      ::std::string* graph_def);

  // optional .tensorflow.Summary summary = 5;
  bool has_summary() const;
  void clear_summary();
  static const int kSummaryFieldNumber = 5;
  private:
  void _slow_mutable_summary();
  void _slow_set_allocated_summary(
      ::google::protobuf::Arena* message_arena, ::tensorflow::Summary** summary);
  ::tensorflow::Summary* _slow_release_summary();
  public:
  const ::tensorflow::Summary& summary() const;
  ::tensorflow::Summary* mutable_summary();
  ::tensorflow::Summary* release_summary();
  void set_allocated_summary(::tensorflow::Summary* summary);
  ::tensorflow::Summary* unsafe_arena_release_summary();
  void unsafe_arena_set_allocated_summary(
      ::tensorflow::Summary* summary);

  // optional .tensorflow.LogMessage log_message = 6;
  bool has_log_message() const;
  void clear_log_message();
  static const int kLogMessageFieldNumber = 6;
  private:
  void _slow_mutable_log_message();
  void _slow_set_allocated_log_message(
      ::google::protobuf::Arena* message_arena, ::tensorflow::LogMessage** log_message);
  ::tensorflow::LogMessage* _slow_release_log_message();
  public:
  const ::tensorflow::LogMessage& log_message() const;
  ::tensorflow::LogMessage* mutable_log_message();
  ::tensorflow::LogMessage* release_log_message();
  void set_allocated_log_message(::tensorflow::LogMessage* log_message);
  ::tensorflow::LogMessage* unsafe_arena_release_log_message();
  void unsafe_arena_set_allocated_log_message(
      ::tensorflow::LogMessage* log_message);

  // optional .tensorflow.SessionLog session_log = 7;
  bool has_session_log() const;
  void clear_session_log();
  static const int kSessionLogFieldNumber = 7;
  private:
  void _slow_mutable_session_log();
  void _slow_set_allocated_session_log(
      ::google::protobuf::Arena* message_arena, ::tensorflow::SessionLog** session_log);
  ::tensorflow::SessionLog* _slow_release_session_log();
  public:
  const ::tensorflow::SessionLog& session_log() const;
  ::tensorflow::SessionLog* mutable_session_log();
  ::tensorflow::SessionLog* release_session_log();
  void set_allocated_session_log(::tensorflow::SessionLog* session_log);
  ::tensorflow::SessionLog* unsafe_arena_release_session_log();
  void unsafe_arena_set_allocated_session_log(
      ::tensorflow::SessionLog* session_log);

  // optional .tensorflow.TaggedRunMetadata tagged_run_metadata = 8;
  bool has_tagged_run_metadata() const;
  void clear_tagged_run_metadata();
  static const int kTaggedRunMetadataFieldNumber = 8;
  private:
  void _slow_mutable_tagged_run_metadata();
  void _slow_set_allocated_tagged_run_metadata(
      ::google::protobuf::Arena* message_arena, ::tensorflow::TaggedRunMetadata** tagged_run_metadata);
  ::tensorflow::TaggedRunMetadata* _slow_release_tagged_run_metadata();
  public:
  const ::tensorflow::TaggedRunMetadata& tagged_run_metadata() const;
  ::tensorflow::TaggedRunMetadata* mutable_tagged_run_metadata();
  ::tensorflow::TaggedRunMetadata* release_tagged_run_metadata();
  void set_allocated_tagged_run_metadata(::tensorflow::TaggedRunMetadata* tagged_run_metadata);
  ::tensorflow::TaggedRunMetadata* unsafe_arena_release_tagged_run_metadata();
  void unsafe_arena_set_allocated_tagged_run_metadata(
      ::tensorflow::TaggedRunMetadata* tagged_run_metadata);

  // optional bytes meta_graph_def = 9;
  private:
  bool has_meta_graph_def() const;
  public:
  void clear_meta_graph_def();
  static const int kMetaGraphDefFieldNumber = 9;
  const ::std::string& meta_graph_def() const;
  void set_meta_graph_def(const ::std::string& value);
  void set_meta_graph_def(const char* value);
  void set_meta_graph_def(const void* value, size_t size);
  ::std::string* mutable_meta_graph_def();
  ::std::string* release_meta_graph_def();
  void set_allocated_meta_graph_def(::std::string* meta_graph_def);
  ::std::string* unsafe_arena_release_meta_graph_def();
  void unsafe_arena_set_allocated_meta_graph_def(
      ::std::string* meta_graph_def);

  WhatCase what_case() const;
  // @@protoc_insertion_point(class_scope:tensorflow.Event)
 private:
  inline void set_has_file_version();
  inline void set_has_graph_def();
  inline void set_has_summary();
  inline void set_has_log_message();
  inline void set_has_session_log();
  inline void set_has_tagged_run_metadata();
  inline void set_has_meta_graph_def();

  inline bool has_what() const;
  void clear_what();
  inline void clear_has_what();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  friend class ::google::protobuf::Arena;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  double wall_time_;
  ::google::protobuf::int64 step_;
  union WhatUnion {
    WhatUnion() {}
    ::google::protobuf::internal::ArenaStringPtr file_version_;
    ::google::protobuf::internal::ArenaStringPtr graph_def_;
    ::tensorflow::Summary* summary_;
    ::tensorflow::LogMessage* log_message_;
    ::tensorflow::SessionLog* session_log_;
    ::tensorflow::TaggedRunMetadata* tagged_run_metadata_;
    ::google::protobuf::internal::ArenaStringPtr meta_graph_def_;
  } what_;
  mutable int _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend void  protobuf_InitDefaults_tensorboard_2eproto_impl();
  friend void  protobuf_AddDesc_tensorboard_2eproto_impl();
  friend void protobuf_AssignDesc_tensorboard_2eproto();
  friend void protobuf_ShutdownFile_tensorboard_2eproto();

  void InitAsDefaultInstance();
};
extern ::google::protobuf::internal::ExplicitlyConstructed<Event> Event_default_instance_;

// -------------------------------------------------------------------

class LogMessage : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:tensorflow.LogMessage) */ {
 public:
  LogMessage();
  virtual ~LogMessage();

  LogMessage(const LogMessage& from);

  inline LogMessage& operator=(const LogMessage& from) {
    CopyFrom(from);
    return *this;
  }

  inline ::google::protobuf::Arena* GetArena() const { return GetArenaNoVirtual(); }
  inline void* GetMaybeArenaPointer() const {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const LogMessage& default_instance();

  static const LogMessage* internal_default_instance();

  void UnsafeArenaSwap(LogMessage* other);
  void Swap(LogMessage* other);

  // implements Message ----------------------------------------------

  inline LogMessage* New() const { return New(NULL); }

  LogMessage* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const LogMessage& from);
  void MergeFrom(const LogMessage& from);
  void Clear();
  bool IsInitialized() const;

  size_t ByteSizeLong() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(LogMessage* other);
  void UnsafeMergeFrom(const LogMessage& from);
  protected:
  explicit LogMessage(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef LogMessage_Level Level;
  static const Level UNKNOWN =
    LogMessage_Level_UNKNOWN;
  static const Level DEBUG =
    LogMessage_Level_DEBUG;
  static const Level INFO =
    LogMessage_Level_INFO;
  static const Level WARN =
    LogMessage_Level_WARN;
  static const Level ERROR =
    LogMessage_Level_ERROR;
  static const Level FATAL =
    LogMessage_Level_FATAL;
  static inline bool Level_IsValid(int value) {
    return LogMessage_Level_IsValid(value);
  }
  static const Level Level_MIN =
    LogMessage_Level_Level_MIN;
  static const Level Level_MAX =
    LogMessage_Level_Level_MAX;
  static const int Level_ARRAYSIZE =
    LogMessage_Level_Level_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Level_descriptor() {
    return LogMessage_Level_descriptor();
  }
  static inline const ::std::string& Level_Name(Level value) {
    return LogMessage_Level_Name(value);
  }
  static inline bool Level_Parse(const ::std::string& name,
      Level* value) {
    return LogMessage_Level_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional .tensorflow.LogMessage.Level level = 1;
  void clear_level();
  static const int kLevelFieldNumber = 1;
  ::tensorflow::LogMessage_Level level() const;
  void set_level(::tensorflow::LogMessage_Level value);

  // optional string message = 2;
  void clear_message();
  static const int kMessageFieldNumber = 2;
  const ::std::string& message() const;
  void set_message(const ::std::string& value);
  void set_message(const char* value);
  void set_message(const char* value, size_t size);
  ::std::string* mutable_message();
  ::std::string* release_message();
  void set_allocated_message(::std::string* message);
  ::std::string* unsafe_arena_release_message();
  void unsafe_arena_set_allocated_message(
      ::std::string* message);

  // @@protoc_insertion_point(class_scope:tensorflow.LogMessage)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  friend class ::google::protobuf::Arena;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::ArenaStringPtr message_;
  int level_;
  mutable int _cached_size_;
  friend void  protobuf_InitDefaults_tensorboard_2eproto_impl();
  friend void  protobuf_AddDesc_tensorboard_2eproto_impl();
  friend void protobuf_AssignDesc_tensorboard_2eproto();
  friend void protobuf_ShutdownFile_tensorboard_2eproto();

  void InitAsDefaultInstance();
};
extern ::google::protobuf::internal::ExplicitlyConstructed<LogMessage> LogMessage_default_instance_;

// -------------------------------------------------------------------

class SessionLog : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:tensorflow.SessionLog) */ {
 public:
  SessionLog();
  virtual ~SessionLog();

  SessionLog(const SessionLog& from);

  inline SessionLog& operator=(const SessionLog& from) {
    CopyFrom(from);
    return *this;
  }

  inline ::google::protobuf::Arena* GetArena() const { return GetArenaNoVirtual(); }
  inline void* GetMaybeArenaPointer() const {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const SessionLog& default_instance();

  static const SessionLog* internal_default_instance();

  void UnsafeArenaSwap(SessionLog* other);
  void Swap(SessionLog* other);

  // implements Message ----------------------------------------------

  inline SessionLog* New() const { return New(NULL); }

  SessionLog* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SessionLog& from);
  void MergeFrom(const SessionLog& from);
  void Clear();
  bool IsInitialized() const;

  size_t ByteSizeLong() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(SessionLog* other);
  void UnsafeMergeFrom(const SessionLog& from);
  protected:
  explicit SessionLog(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef SessionLog_SessionStatus SessionStatus;
  static const SessionStatus STATUS_UNSPECIFIED =
    SessionLog_SessionStatus_STATUS_UNSPECIFIED;
  static const SessionStatus START =
    SessionLog_SessionStatus_START;
  static const SessionStatus STOP =
    SessionLog_SessionStatus_STOP;
  static const SessionStatus CHECKPOINT =
    SessionLog_SessionStatus_CHECKPOINT;
  static inline bool SessionStatus_IsValid(int value) {
    return SessionLog_SessionStatus_IsValid(value);
  }
  static const SessionStatus SessionStatus_MIN =
    SessionLog_SessionStatus_SessionStatus_MIN;
  static const SessionStatus SessionStatus_MAX =
    SessionLog_SessionStatus_SessionStatus_MAX;
  static const int SessionStatus_ARRAYSIZE =
    SessionLog_SessionStatus_SessionStatus_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  SessionStatus_descriptor() {
    return SessionLog_SessionStatus_descriptor();
  }
  static inline const ::std::string& SessionStatus_Name(SessionStatus value) {
    return SessionLog_SessionStatus_Name(value);
  }
  static inline bool SessionStatus_Parse(const ::std::string& name,
      SessionStatus* value) {
    return SessionLog_SessionStatus_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional .tensorflow.SessionLog.SessionStatus status = 1;
  void clear_status();
  static const int kStatusFieldNumber = 1;
  ::tensorflow::SessionLog_SessionStatus status() const;
  void set_status(::tensorflow::SessionLog_SessionStatus value);

  // optional string checkpoint_path = 2;
  void clear_checkpoint_path();
  static const int kCheckpointPathFieldNumber = 2;
  const ::std::string& checkpoint_path() const;
  void set_checkpoint_path(const ::std::string& value);
  void set_checkpoint_path(const char* value);
  void set_checkpoint_path(const char* value, size_t size);
  ::std::string* mutable_checkpoint_path();
  ::std::string* release_checkpoint_path();
  void set_allocated_checkpoint_path(::std::string* checkpoint_path);
  ::std::string* unsafe_arena_release_checkpoint_path();
  void unsafe_arena_set_allocated_checkpoint_path(
      ::std::string* checkpoint_path);

  // optional string msg = 3;
  void clear_msg();
  static const int kMsgFieldNumber = 3;
  const ::std::string& msg() const;
  void set_msg(const ::std::string& value);
  void set_msg(const char* value);
  void set_msg(const char* value, size_t size);
  ::std::string* mutable_msg();
  ::std::string* release_msg();
  void set_allocated_msg(::std::string* msg);
  ::std::string* unsafe_arena_release_msg();
  void unsafe_arena_set_allocated_msg(
      ::std::string* msg);

  // @@protoc_insertion_point(class_scope:tensorflow.SessionLog)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  friend class ::google::protobuf::Arena;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::ArenaStringPtr checkpoint_path_;
  ::google::protobuf::internal::ArenaStringPtr msg_;
  int status_;
  mutable int _cached_size_;
  friend void  protobuf_InitDefaults_tensorboard_2eproto_impl();
  friend void  protobuf_AddDesc_tensorboard_2eproto_impl();
  friend void protobuf_AssignDesc_tensorboard_2eproto();
  friend void protobuf_ShutdownFile_tensorboard_2eproto();

  void InitAsDefaultInstance();
};
extern ::google::protobuf::internal::ExplicitlyConstructed<SessionLog> SessionLog_default_instance_;

// -------------------------------------------------------------------

class TaggedRunMetadata : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:tensorflow.TaggedRunMetadata) */ {
 public:
  TaggedRunMetadata();
  virtual ~TaggedRunMetadata();

  TaggedRunMetadata(const TaggedRunMetadata& from);

  inline TaggedRunMetadata& operator=(const TaggedRunMetadata& from) {
    CopyFrom(from);
    return *this;
  }

  inline ::google::protobuf::Arena* GetArena() const { return GetArenaNoVirtual(); }
  inline void* GetMaybeArenaPointer() const {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const TaggedRunMetadata& default_instance();

  static const TaggedRunMetadata* internal_default_instance();

  void UnsafeArenaSwap(TaggedRunMetadata* other);
  void Swap(TaggedRunMetadata* other);

  // implements Message ----------------------------------------------

  inline TaggedRunMetadata* New() const { return New(NULL); }

  TaggedRunMetadata* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TaggedRunMetadata& from);
  void MergeFrom(const TaggedRunMetadata& from);
  void Clear();
  bool IsInitialized() const;

  size_t ByteSizeLong() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(TaggedRunMetadata* other);
  void UnsafeMergeFrom(const TaggedRunMetadata& from);
  protected:
  explicit TaggedRunMetadata(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string tag = 1;
  void clear_tag();
  static const int kTagFieldNumber = 1;
  const ::std::string& tag() const;
  void set_tag(const ::std::string& value);
  void set_tag(const char* value);
  void set_tag(const char* value, size_t size);
  ::std::string* mutable_tag();
  ::std::string* release_tag();
  void set_allocated_tag(::std::string* tag);
  ::std::string* unsafe_arena_release_tag();
  void unsafe_arena_set_allocated_tag(
      ::std::string* tag);

  // optional bytes run_metadata = 2;
  void clear_run_metadata();
  static const int kRunMetadataFieldNumber = 2;
  const ::std::string& run_metadata() const;
  void set_run_metadata(const ::std::string& value);
  void set_run_metadata(const char* value);
  void set_run_metadata(const void* value, size_t size);
  ::std::string* mutable_run_metadata();
  ::std::string* release_run_metadata();
  void set_allocated_run_metadata(::std::string* run_metadata);
  ::std::string* unsafe_arena_release_run_metadata();
  void unsafe_arena_set_allocated_run_metadata(
      ::std::string* run_metadata);

  // @@protoc_insertion_point(class_scope:tensorflow.TaggedRunMetadata)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  friend class ::google::protobuf::Arena;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::ArenaStringPtr tag_;
  ::google::protobuf::internal::ArenaStringPtr run_metadata_;
  mutable int _cached_size_;
  friend void  protobuf_InitDefaults_tensorboard_2eproto_impl();
  friend void  protobuf_AddDesc_tensorboard_2eproto_impl();
  friend void protobuf_AssignDesc_tensorboard_2eproto();
  friend void protobuf_ShutdownFile_tensorboard_2eproto();

  void InitAsDefaultInstance();
};
extern ::google::protobuf::internal::ExplicitlyConstructed<TaggedRunMetadata> TaggedRunMetadata_default_instance_;

// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
// TensorShapeProto_Dim

// optional int64 size = 1;
inline void TensorShapeProto_Dim::clear_size() {
  size_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 TensorShapeProto_Dim::size() const {
  // @@protoc_insertion_point(field_get:tensorflow.TensorShapeProto.Dim.size)
  return size_;
}
inline void TensorShapeProto_Dim::set_size(::google::protobuf::int64 value) {
  
  size_ = value;
  // @@protoc_insertion_point(field_set:tensorflow.TensorShapeProto.Dim.size)
}

// optional string name = 2;
inline void TensorShapeProto_Dim::clear_name() {
  name_.ClearToEmpty(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline const ::std::string& TensorShapeProto_Dim::name() const {
  // @@protoc_insertion_point(field_get:tensorflow.TensorShapeProto.Dim.name)
  return name_.Get(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TensorShapeProto_Dim::set_name(const ::std::string& value) {
  
  name_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set:tensorflow.TensorShapeProto.Dim.name)
}
inline void TensorShapeProto_Dim::set_name(const char* value) {
  
  name_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_char:tensorflow.TensorShapeProto.Dim.name)
}
inline void TensorShapeProto_Dim::set_name(const char* value,
    size_t size) {
  
  name_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_pointer:tensorflow.TensorShapeProto.Dim.name)
}
inline ::std::string* TensorShapeProto_Dim::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:tensorflow.TensorShapeProto.Dim.name)
  return name_.Mutable(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline ::std::string* TensorShapeProto_Dim::release_name() {
  // @@protoc_insertion_point(field_release:tensorflow.TensorShapeProto.Dim.name)
  
  return name_.Release(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline ::std::string* TensorShapeProto_Dim::unsafe_arena_release_name() {
  // @@protoc_insertion_point(field_unsafe_arena_release:tensorflow.TensorShapeProto.Dim.name)
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  
  return name_.UnsafeArenaRelease(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      GetArenaNoVirtual());
}
inline void TensorShapeProto_Dim::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    
  } else {
    
  }
  name_.SetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name,
      GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_allocated:tensorflow.TensorShapeProto.Dim.name)
}
inline void TensorShapeProto_Dim::unsafe_arena_set_allocated_name(
    ::std::string* name) {
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  if (name != NULL) {
    
  } else {
    
  }
  name_.UnsafeArenaSetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      name, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tensorflow.TensorShapeProto.Dim.name)
}

inline const TensorShapeProto_Dim* TensorShapeProto_Dim::internal_default_instance() {
  return &TensorShapeProto_Dim_default_instance_.get();
}
// -------------------------------------------------------------------

// TensorShapeProto

// repeated .tensorflow.TensorShapeProto.Dim dim = 2;
inline int TensorShapeProto::dim_size() const {
  return dim_.size();
}
inline void TensorShapeProto::clear_dim() {
  dim_.Clear();
}
inline const ::tensorflow::TensorShapeProto_Dim& TensorShapeProto::dim(int index) const {
  // @@protoc_insertion_point(field_get:tensorflow.TensorShapeProto.dim)
  return dim_.Get(index);
}
inline ::tensorflow::TensorShapeProto_Dim* TensorShapeProto::mutable_dim(int index) {
  // @@protoc_insertion_point(field_mutable:tensorflow.TensorShapeProto.dim)
  return dim_.Mutable(index);
}
inline ::tensorflow::TensorShapeProto_Dim* TensorShapeProto::add_dim() {
  // @@protoc_insertion_point(field_add:tensorflow.TensorShapeProto.dim)
  return dim_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::tensorflow::TensorShapeProto_Dim >*
TensorShapeProto::mutable_dim() {
  // @@protoc_insertion_point(field_mutable_list:tensorflow.TensorShapeProto.dim)
  return &dim_;
}
inline const ::google::protobuf::RepeatedPtrField< ::tensorflow::TensorShapeProto_Dim >&
TensorShapeProto::dim() const {
  // @@protoc_insertion_point(field_list:tensorflow.TensorShapeProto.dim)
  return dim_;
}

// optional bool unknown_rank = 3;
inline void TensorShapeProto::clear_unknown_rank() {
  unknown_rank_ = false;
}
inline bool TensorShapeProto::unknown_rank() const {
  // @@protoc_insertion_point(field_get:tensorflow.TensorShapeProto.unknown_rank)
  return unknown_rank_;
}
inline void TensorShapeProto::set_unknown_rank(bool value) {
  
  unknown_rank_ = value;
  // @@protoc_insertion_point(field_set:tensorflow.TensorShapeProto.unknown_rank)
}

inline const TensorShapeProto* TensorShapeProto::internal_default_instance() {
  return &TensorShapeProto_default_instance_.get();
}
// -------------------------------------------------------------------

// TensorProto

// optional .tensorflow.DataType dtype = 1;
inline void TensorProto::clear_dtype() {
  dtype_ = 0;
}
inline ::tensorflow::DataType TensorProto::dtype() const {
  // @@protoc_insertion_point(field_get:tensorflow.TensorProto.dtype)
  return static_cast< ::tensorflow::DataType >(dtype_);
}
inline void TensorProto::set_dtype(::tensorflow::DataType value) {
  
  dtype_ = value;
  // @@protoc_insertion_point(field_set:tensorflow.TensorProto.dtype)
}

// optional .tensorflow.TensorShapeProto tensor_shape = 2;
inline bool TensorProto::has_tensor_shape() const {
  return this != internal_default_instance() && tensor_shape_ != NULL;
}
inline void TensorProto::clear_tensor_shape() {
  if (GetArenaNoVirtual() == NULL && tensor_shape_ != NULL) delete tensor_shape_;
  tensor_shape_ = NULL;
}
inline const ::tensorflow::TensorShapeProto& TensorProto::tensor_shape() const {
  // @@protoc_insertion_point(field_get:tensorflow.TensorProto.tensor_shape)
  return tensor_shape_ != NULL ? *tensor_shape_
                         : *::tensorflow::TensorShapeProto::internal_default_instance();
}
inline ::tensorflow::TensorShapeProto* TensorProto::mutable_tensor_shape() {
  
  if (tensor_shape_ == NULL) {
    _slow_mutable_tensor_shape();
  }
  // @@protoc_insertion_point(field_mutable:tensorflow.TensorProto.tensor_shape)
  return tensor_shape_;
}
inline ::tensorflow::TensorShapeProto* TensorProto::release_tensor_shape() {
  // @@protoc_insertion_point(field_release:tensorflow.TensorProto.tensor_shape)
  
  if (GetArenaNoVirtual() != NULL) {
    return _slow_release_tensor_shape();
  } else {
    ::tensorflow::TensorShapeProto* temp = tensor_shape_;
    tensor_shape_ = NULL;
    return temp;
  }
}
inline  void TensorProto::set_allocated_tensor_shape(::tensorflow::TensorShapeProto* tensor_shape) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete tensor_shape_;
  }
  if (tensor_shape != NULL) {
    _slow_set_allocated_tensor_shape(message_arena, &tensor_shape);
  }
  tensor_shape_ = tensor_shape;
  if (tensor_shape) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:tensorflow.TensorProto.tensor_shape)
}

// optional int32 version_number = 3;
inline void TensorProto::clear_version_number() {
  version_number_ = 0;
}
inline ::google::protobuf::int32 TensorProto::version_number() const {
  // @@protoc_insertion_point(field_get:tensorflow.TensorProto.version_number)
  return version_number_;
}
inline void TensorProto::set_version_number(::google::protobuf::int32 value) {
  
  version_number_ = value;
  // @@protoc_insertion_point(field_set:tensorflow.TensorProto.version_number)
}

// optional bytes tensor_content = 4;
inline void TensorProto::clear_tensor_content() {
  tensor_content_.ClearToEmpty(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline const ::std::string& TensorProto::tensor_content() const {
  // @@protoc_insertion_point(field_get:tensorflow.TensorProto.tensor_content)
  return tensor_content_.Get(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TensorProto::set_tensor_content(const ::std::string& value) {
  
  tensor_content_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set:tensorflow.TensorProto.tensor_content)
}
inline void TensorProto::set_tensor_content(const char* value) {
  
  tensor_content_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_char:tensorflow.TensorProto.tensor_content)
}
inline void TensorProto::set_tensor_content(const void* value,
    size_t size) {
  
  tensor_content_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_pointer:tensorflow.TensorProto.tensor_content)
}
inline ::std::string* TensorProto::mutable_tensor_content() {
  
  // @@protoc_insertion_point(field_mutable:tensorflow.TensorProto.tensor_content)
  return tensor_content_.Mutable(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline ::std::string* TensorProto::release_tensor_content() {
  // @@protoc_insertion_point(field_release:tensorflow.TensorProto.tensor_content)
  
  return tensor_content_.Release(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline ::std::string* TensorProto::unsafe_arena_release_tensor_content() {
  // @@protoc_insertion_point(field_unsafe_arena_release:tensorflow.TensorProto.tensor_content)
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  
  return tensor_content_.UnsafeArenaRelease(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      GetArenaNoVirtual());
}
inline void TensorProto::set_allocated_tensor_content(::std::string* tensor_content) {
  if (tensor_content != NULL) {
    
  } else {
    
  }
  tensor_content_.SetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), tensor_content,
      GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_allocated:tensorflow.TensorProto.tensor_content)
}
inline void TensorProto::unsafe_arena_set_allocated_tensor_content(
    ::std::string* tensor_content) {
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  if (tensor_content != NULL) {
    
  } else {
    
  }
  tensor_content_.UnsafeArenaSetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      tensor_content, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tensorflow.TensorProto.tensor_content)
}

// repeated int32 half_val = 13 [packed = true];
inline int TensorProto::half_val_size() const {
  return half_val_.size();
}
inline void TensorProto::clear_half_val() {
  half_val_.Clear();
}
inline ::google::protobuf::int32 TensorProto::half_val(int index) const {
  // @@protoc_insertion_point(field_get:tensorflow.TensorProto.half_val)
  return half_val_.Get(index);
}
inline void TensorProto::set_half_val(int index, ::google::protobuf::int32 value) {
  half_val_.Set(index, value);
  // @@protoc_insertion_point(field_set:tensorflow.TensorProto.half_val)
}
inline void TensorProto::add_half_val(::google::protobuf::int32 value) {
  half_val_.Add(value);
  // @@protoc_insertion_point(field_add:tensorflow.TensorProto.half_val)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
TensorProto::half_val() const {
  // @@protoc_insertion_point(field_list:tensorflow.TensorProto.half_val)
  return half_val_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
TensorProto::mutable_half_val() {
  // @@protoc_insertion_point(field_mutable_list:tensorflow.TensorProto.half_val)
  return &half_val_;
}

// repeated float float_val = 5 [packed = true];
inline int TensorProto::float_val_size() const {
  return float_val_.size();
}
inline void TensorProto::clear_float_val() {
  float_val_.Clear();
}
inline float TensorProto::float_val(int index) const {
  // @@protoc_insertion_point(field_get:tensorflow.TensorProto.float_val)
  return float_val_.Get(index);
}
inline void TensorProto::set_float_val(int index, float value) {
  float_val_.Set(index, value);
  // @@protoc_insertion_point(field_set:tensorflow.TensorProto.float_val)
}
inline void TensorProto::add_float_val(float value) {
  float_val_.Add(value);
  // @@protoc_insertion_point(field_add:tensorflow.TensorProto.float_val)
}
inline const ::google::protobuf::RepeatedField< float >&
TensorProto::float_val() const {
  // @@protoc_insertion_point(field_list:tensorflow.TensorProto.float_val)
  return float_val_;
}
inline ::google::protobuf::RepeatedField< float >*
TensorProto::mutable_float_val() {
  // @@protoc_insertion_point(field_mutable_list:tensorflow.TensorProto.float_val)
  return &float_val_;
}

// repeated double double_val = 6 [packed = true];
inline int TensorProto::double_val_size() const {
  return double_val_.size();
}
inline void TensorProto::clear_double_val() {
  double_val_.Clear();
}
inline double TensorProto::double_val(int index) const {
  // @@protoc_insertion_point(field_get:tensorflow.TensorProto.double_val)
  return double_val_.Get(index);
}
inline void TensorProto::set_double_val(int index, double value) {
  double_val_.Set(index, value);
  // @@protoc_insertion_point(field_set:tensorflow.TensorProto.double_val)
}
inline void TensorProto::add_double_val(double value) {
  double_val_.Add(value);
  // @@protoc_insertion_point(field_add:tensorflow.TensorProto.double_val)
}
inline const ::google::protobuf::RepeatedField< double >&
TensorProto::double_val() const {
  // @@protoc_insertion_point(field_list:tensorflow.TensorProto.double_val)
  return double_val_;
}
inline ::google::protobuf::RepeatedField< double >*
TensorProto::mutable_double_val() {
  // @@protoc_insertion_point(field_mutable_list:tensorflow.TensorProto.double_val)
  return &double_val_;
}

// repeated int32 int_val = 7 [packed = true];
inline int TensorProto::int_val_size() const {
  return int_val_.size();
}
inline void TensorProto::clear_int_val() {
  int_val_.Clear();
}
inline ::google::protobuf::int32 TensorProto::int_val(int index) const {
  // @@protoc_insertion_point(field_get:tensorflow.TensorProto.int_val)
  return int_val_.Get(index);
}
inline void TensorProto::set_int_val(int index, ::google::protobuf::int32 value) {
  int_val_.Set(index, value);
  // @@protoc_insertion_point(field_set:tensorflow.TensorProto.int_val)
}
inline void TensorProto::add_int_val(::google::protobuf::int32 value) {
  int_val_.Add(value);
  // @@protoc_insertion_point(field_add:tensorflow.TensorProto.int_val)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
TensorProto::int_val() const {
  // @@protoc_insertion_point(field_list:tensorflow.TensorProto.int_val)
  return int_val_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
TensorProto::mutable_int_val() {
  // @@protoc_insertion_point(field_mutable_list:tensorflow.TensorProto.int_val)
  return &int_val_;
}

// repeated bytes string_val = 8;
inline int TensorProto::string_val_size() const {
  return string_val_.size();
}
inline void TensorProto::clear_string_val() {
  string_val_.Clear();
}
inline const ::std::string& TensorProto::string_val(int index) const {
  // @@protoc_insertion_point(field_get:tensorflow.TensorProto.string_val)
  return string_val_.Get(index);
}
inline ::std::string* TensorProto::mutable_string_val(int index) {
  // @@protoc_insertion_point(field_mutable:tensorflow.TensorProto.string_val)
  return string_val_.Mutable(index);
}
inline void TensorProto::set_string_val(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:tensorflow.TensorProto.string_val)
  string_val_.Mutable(index)->assign(value);
}
inline void TensorProto::set_string_val(int index, const char* value) {
  string_val_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:tensorflow.TensorProto.string_val)
}
inline void TensorProto::set_string_val(int index, const void* value, size_t size) {
  string_val_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:tensorflow.TensorProto.string_val)
}
inline ::std::string* TensorProto::add_string_val() {
  // @@protoc_insertion_point(field_add_mutable:tensorflow.TensorProto.string_val)
  return string_val_.Add();
}
inline void TensorProto::add_string_val(const ::std::string& value) {
  string_val_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:tensorflow.TensorProto.string_val)
}
inline void TensorProto::add_string_val(const char* value) {
  string_val_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:tensorflow.TensorProto.string_val)
}
inline void TensorProto::add_string_val(const void* value, size_t size) {
  string_val_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:tensorflow.TensorProto.string_val)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
TensorProto::string_val() const {
  // @@protoc_insertion_point(field_list:tensorflow.TensorProto.string_val)
  return string_val_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
TensorProto::mutable_string_val() {
  // @@protoc_insertion_point(field_mutable_list:tensorflow.TensorProto.string_val)
  return &string_val_;
}

// repeated float scomplex_val = 9 [packed = true];
inline int TensorProto::scomplex_val_size() const {
  return scomplex_val_.size();
}
inline void TensorProto::clear_scomplex_val() {
  scomplex_val_.Clear();
}
inline float TensorProto::scomplex_val(int index) const {
  // @@protoc_insertion_point(field_get:tensorflow.TensorProto.scomplex_val)
  return scomplex_val_.Get(index);
}
inline void TensorProto::set_scomplex_val(int index, float value) {
  scomplex_val_.Set(index, value);
  // @@protoc_insertion_point(field_set:tensorflow.TensorProto.scomplex_val)
}
inline void TensorProto::add_scomplex_val(float value) {
  scomplex_val_.Add(value);
  // @@protoc_insertion_point(field_add:tensorflow.TensorProto.scomplex_val)
}
inline const ::google::protobuf::RepeatedField< float >&
TensorProto::scomplex_val() const {
  // @@protoc_insertion_point(field_list:tensorflow.TensorProto.scomplex_val)
  return scomplex_val_;
}
inline ::google::protobuf::RepeatedField< float >*
TensorProto::mutable_scomplex_val() {
  // @@protoc_insertion_point(field_mutable_list:tensorflow.TensorProto.scomplex_val)
  return &scomplex_val_;
}

// repeated int64 int64_val = 10 [packed = true];
inline int TensorProto::int64_val_size() const {
  return int64_val_.size();
}
inline void TensorProto::clear_int64_val() {
  int64_val_.Clear();
}
inline ::google::protobuf::int64 TensorProto::int64_val(int index) const {
  // @@protoc_insertion_point(field_get:tensorflow.TensorProto.int64_val)
  return int64_val_.Get(index);
}
inline void TensorProto::set_int64_val(int index, ::google::protobuf::int64 value) {
  int64_val_.Set(index, value);
  // @@protoc_insertion_point(field_set:tensorflow.TensorProto.int64_val)
}
inline void TensorProto::add_int64_val(::google::protobuf::int64 value) {
  int64_val_.Add(value);
  // @@protoc_insertion_point(field_add:tensorflow.TensorProto.int64_val)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int64 >&
TensorProto::int64_val() const {
  // @@protoc_insertion_point(field_list:tensorflow.TensorProto.int64_val)
  return int64_val_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int64 >*
TensorProto::mutable_int64_val() {
  // @@protoc_insertion_point(field_mutable_list:tensorflow.TensorProto.int64_val)
  return &int64_val_;
}

// repeated bool bool_val = 11 [packed = true];
inline int TensorProto::bool_val_size() const {
  return bool_val_.size();
}
inline void TensorProto::clear_bool_val() {
  bool_val_.Clear();
}
inline bool TensorProto::bool_val(int index) const {
  // @@protoc_insertion_point(field_get:tensorflow.TensorProto.bool_val)
  return bool_val_.Get(index);
}
inline void TensorProto::set_bool_val(int index, bool value) {
  bool_val_.Set(index, value);
  // @@protoc_insertion_point(field_set:tensorflow.TensorProto.bool_val)
}
inline void TensorProto::add_bool_val(bool value) {
  bool_val_.Add(value);
  // @@protoc_insertion_point(field_add:tensorflow.TensorProto.bool_val)
}
inline const ::google::protobuf::RepeatedField< bool >&
TensorProto::bool_val() const {
  // @@protoc_insertion_point(field_list:tensorflow.TensorProto.bool_val)
  return bool_val_;
}
inline ::google::protobuf::RepeatedField< bool >*
TensorProto::mutable_bool_val() {
  // @@protoc_insertion_point(field_mutable_list:tensorflow.TensorProto.bool_val)
  return &bool_val_;
}

// repeated double dcomplex_val = 12 [packed = true];
inline int TensorProto::dcomplex_val_size() const {
  return dcomplex_val_.size();
}
inline void TensorProto::clear_dcomplex_val() {
  dcomplex_val_.Clear();
}
inline double TensorProto::dcomplex_val(int index) const {
  // @@protoc_insertion_point(field_get:tensorflow.TensorProto.dcomplex_val)
  return dcomplex_val_.Get(index);
}
inline void TensorProto::set_dcomplex_val(int index, double value) {
  dcomplex_val_.Set(index, value);
  // @@protoc_insertion_point(field_set:tensorflow.TensorProto.dcomplex_val)
}
inline void TensorProto::add_dcomplex_val(double value) {
  dcomplex_val_.Add(value);
  // @@protoc_insertion_point(field_add:tensorflow.TensorProto.dcomplex_val)
}
inline const ::google::protobuf::RepeatedField< double >&
TensorProto::dcomplex_val() const {
  // @@protoc_insertion_point(field_list:tensorflow.TensorProto.dcomplex_val)
  return dcomplex_val_;
}
inline ::google::protobuf::RepeatedField< double >*
TensorProto::mutable_dcomplex_val() {
  // @@protoc_insertion_point(field_mutable_list:tensorflow.TensorProto.dcomplex_val)
  return &dcomplex_val_;
}

inline const TensorProto* TensorProto::internal_default_instance() {
  return &TensorProto_default_instance_.get();
}
// -------------------------------------------------------------------

// VersionDef

// optional int32 producer = 1;
inline void VersionDef::clear_producer() {
  producer_ = 0;
}
inline ::google::protobuf::int32 VersionDef::producer() const {
  // @@protoc_insertion_point(field_get:tensorflow.VersionDef.producer)
  return producer_;
}
inline void VersionDef::set_producer(::google::protobuf::int32 value) {
  
  producer_ = value;
  // @@protoc_insertion_point(field_set:tensorflow.VersionDef.producer)
}

// optional int32 min_consumer = 2;
inline void VersionDef::clear_min_consumer() {
  min_consumer_ = 0;
}
inline ::google::protobuf::int32 VersionDef::min_consumer() const {
  // @@protoc_insertion_point(field_get:tensorflow.VersionDef.min_consumer)
  return min_consumer_;
}
inline void VersionDef::set_min_consumer(::google::protobuf::int32 value) {
  
  min_consumer_ = value;
  // @@protoc_insertion_point(field_set:tensorflow.VersionDef.min_consumer)
}

// repeated int32 bad_consumers = 3;
inline int VersionDef::bad_consumers_size() const {
  return bad_consumers_.size();
}
inline void VersionDef::clear_bad_consumers() {
  bad_consumers_.Clear();
}
inline ::google::protobuf::int32 VersionDef::bad_consumers(int index) const {
  // @@protoc_insertion_point(field_get:tensorflow.VersionDef.bad_consumers)
  return bad_consumers_.Get(index);
}
inline void VersionDef::set_bad_consumers(int index, ::google::protobuf::int32 value) {
  bad_consumers_.Set(index, value);
  // @@protoc_insertion_point(field_set:tensorflow.VersionDef.bad_consumers)
}
inline void VersionDef::add_bad_consumers(::google::protobuf::int32 value) {
  bad_consumers_.Add(value);
  // @@protoc_insertion_point(field_add:tensorflow.VersionDef.bad_consumers)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
VersionDef::bad_consumers() const {
  // @@protoc_insertion_point(field_list:tensorflow.VersionDef.bad_consumers)
  return bad_consumers_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
VersionDef::mutable_bad_consumers() {
  // @@protoc_insertion_point(field_mutable_list:tensorflow.VersionDef.bad_consumers)
  return &bad_consumers_;
}

inline const VersionDef* VersionDef::internal_default_instance() {
  return &VersionDef_default_instance_.get();
}
// -------------------------------------------------------------------

// SummaryDescription

// optional string type_hint = 1;
inline void SummaryDescription::clear_type_hint() {
  type_hint_.ClearToEmpty(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline const ::std::string& SummaryDescription::type_hint() const {
  // @@protoc_insertion_point(field_get:tensorflow.SummaryDescription.type_hint)
  return type_hint_.Get(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SummaryDescription::set_type_hint(const ::std::string& value) {
  
  type_hint_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set:tensorflow.SummaryDescription.type_hint)
}
inline void SummaryDescription::set_type_hint(const char* value) {
  
  type_hint_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_char:tensorflow.SummaryDescription.type_hint)
}
inline void SummaryDescription::set_type_hint(const char* value,
    size_t size) {
  
  type_hint_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_pointer:tensorflow.SummaryDescription.type_hint)
}
inline ::std::string* SummaryDescription::mutable_type_hint() {
  
  // @@protoc_insertion_point(field_mutable:tensorflow.SummaryDescription.type_hint)
  return type_hint_.Mutable(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline ::std::string* SummaryDescription::release_type_hint() {
  // @@protoc_insertion_point(field_release:tensorflow.SummaryDescription.type_hint)
  
  return type_hint_.Release(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline ::std::string* SummaryDescription::unsafe_arena_release_type_hint() {
  // @@protoc_insertion_point(field_unsafe_arena_release:tensorflow.SummaryDescription.type_hint)
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  
  return type_hint_.UnsafeArenaRelease(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      GetArenaNoVirtual());
}
inline void SummaryDescription::set_allocated_type_hint(::std::string* type_hint) {
  if (type_hint != NULL) {
    
  } else {
    
  }
  type_hint_.SetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), type_hint,
      GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_allocated:tensorflow.SummaryDescription.type_hint)
}
inline void SummaryDescription::unsafe_arena_set_allocated_type_hint(
    ::std::string* type_hint) {
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  if (type_hint != NULL) {
    
  } else {
    
  }
  type_hint_.UnsafeArenaSetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      type_hint, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tensorflow.SummaryDescription.type_hint)
}

inline const SummaryDescription* SummaryDescription::internal_default_instance() {
  return &SummaryDescription_default_instance_.get();
}
// -------------------------------------------------------------------

// HistogramProto

// optional double min = 1;
inline void HistogramProto::clear_min() {
  min_ = 0;
}
inline double HistogramProto::min() const {
  // @@protoc_insertion_point(field_get:tensorflow.HistogramProto.min)
  return min_;
}
inline void HistogramProto::set_min(double value) {
  
  min_ = value;
  // @@protoc_insertion_point(field_set:tensorflow.HistogramProto.min)
}

// optional double max = 2;
inline void HistogramProto::clear_max() {
  max_ = 0;
}
inline double HistogramProto::max() const {
  // @@protoc_insertion_point(field_get:tensorflow.HistogramProto.max)
  return max_;
}
inline void HistogramProto::set_max(double value) {
  
  max_ = value;
  // @@protoc_insertion_point(field_set:tensorflow.HistogramProto.max)
}

// optional double num = 3;
inline void HistogramProto::clear_num() {
  num_ = 0;
}
inline double HistogramProto::num() const {
  // @@protoc_insertion_point(field_get:tensorflow.HistogramProto.num)
  return num_;
}
inline void HistogramProto::set_num(double value) {
  
  num_ = value;
  // @@protoc_insertion_point(field_set:tensorflow.HistogramProto.num)
}

// optional double sum = 4;
inline void HistogramProto::clear_sum() {
  sum_ = 0;
}
inline double HistogramProto::sum() const {
  // @@protoc_insertion_point(field_get:tensorflow.HistogramProto.sum)
  return sum_;
}
inline void HistogramProto::set_sum(double value) {
  
  sum_ = value;
  // @@protoc_insertion_point(field_set:tensorflow.HistogramProto.sum)
}

// optional double sum_squares = 5;
inline void HistogramProto::clear_sum_squares() {
  sum_squares_ = 0;
}
inline double HistogramProto::sum_squares() const {
  // @@protoc_insertion_point(field_get:tensorflow.HistogramProto.sum_squares)
  return sum_squares_;
}
inline void HistogramProto::set_sum_squares(double value) {
  
  sum_squares_ = value;
  // @@protoc_insertion_point(field_set:tensorflow.HistogramProto.sum_squares)
}

// repeated double bucket_limit = 6 [packed = true];
inline int HistogramProto::bucket_limit_size() const {
  return bucket_limit_.size();
}
inline void HistogramProto::clear_bucket_limit() {
  bucket_limit_.Clear();
}
inline double HistogramProto::bucket_limit(int index) const {
  // @@protoc_insertion_point(field_get:tensorflow.HistogramProto.bucket_limit)
  return bucket_limit_.Get(index);
}
inline void HistogramProto::set_bucket_limit(int index, double value) {
  bucket_limit_.Set(index, value);
  // @@protoc_insertion_point(field_set:tensorflow.HistogramProto.bucket_limit)
}
inline void HistogramProto::add_bucket_limit(double value) {
  bucket_limit_.Add(value);
  // @@protoc_insertion_point(field_add:tensorflow.HistogramProto.bucket_limit)
}
inline const ::google::protobuf::RepeatedField< double >&
HistogramProto::bucket_limit() const {
  // @@protoc_insertion_point(field_list:tensorflow.HistogramProto.bucket_limit)
  return bucket_limit_;
}
inline ::google::protobuf::RepeatedField< double >*
HistogramProto::mutable_bucket_limit() {
  // @@protoc_insertion_point(field_mutable_list:tensorflow.HistogramProto.bucket_limit)
  return &bucket_limit_;
}

// repeated double bucket = 7 [packed = true];
inline int HistogramProto::bucket_size() const {
  return bucket_.size();
}
inline void HistogramProto::clear_bucket() {
  bucket_.Clear();
}
inline double HistogramProto::bucket(int index) const {
  // @@protoc_insertion_point(field_get:tensorflow.HistogramProto.bucket)
  return bucket_.Get(index);
}
inline void HistogramProto::set_bucket(int index, double value) {
  bucket_.Set(index, value);
  // @@protoc_insertion_point(field_set:tensorflow.HistogramProto.bucket)
}
inline void HistogramProto::add_bucket(double value) {
  bucket_.Add(value);
  // @@protoc_insertion_point(field_add:tensorflow.HistogramProto.bucket)
}
inline const ::google::protobuf::RepeatedField< double >&
HistogramProto::bucket() const {
  // @@protoc_insertion_point(field_list:tensorflow.HistogramProto.bucket)
  return bucket_;
}
inline ::google::protobuf::RepeatedField< double >*
HistogramProto::mutable_bucket() {
  // @@protoc_insertion_point(field_mutable_list:tensorflow.HistogramProto.bucket)
  return &bucket_;
}

inline const HistogramProto* HistogramProto::internal_default_instance() {
  return &HistogramProto_default_instance_.get();
}
// -------------------------------------------------------------------

// Summary_Image

// optional int32 height = 1;
inline void Summary_Image::clear_height() {
  height_ = 0;
}
inline ::google::protobuf::int32 Summary_Image::height() const {
  // @@protoc_insertion_point(field_get:tensorflow.Summary.Image.height)
  return height_;
}
inline void Summary_Image::set_height(::google::protobuf::int32 value) {
  
  height_ = value;
  // @@protoc_insertion_point(field_set:tensorflow.Summary.Image.height)
}

// optional int32 width = 2;
inline void Summary_Image::clear_width() {
  width_ = 0;
}
inline ::google::protobuf::int32 Summary_Image::width() const {
  // @@protoc_insertion_point(field_get:tensorflow.Summary.Image.width)
  return width_;
}
inline void Summary_Image::set_width(::google::protobuf::int32 value) {
  
  width_ = value;
  // @@protoc_insertion_point(field_set:tensorflow.Summary.Image.width)
}

// optional int32 colorspace = 3;
inline void Summary_Image::clear_colorspace() {
  colorspace_ = 0;
}
inline ::google::protobuf::int32 Summary_Image::colorspace() const {
  // @@protoc_insertion_point(field_get:tensorflow.Summary.Image.colorspace)
  return colorspace_;
}
inline void Summary_Image::set_colorspace(::google::protobuf::int32 value) {
  
  colorspace_ = value;
  // @@protoc_insertion_point(field_set:tensorflow.Summary.Image.colorspace)
}

// optional bytes encoded_image_string = 4;
inline void Summary_Image::clear_encoded_image_string() {
  encoded_image_string_.ClearToEmpty(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline const ::std::string& Summary_Image::encoded_image_string() const {
  // @@protoc_insertion_point(field_get:tensorflow.Summary.Image.encoded_image_string)
  return encoded_image_string_.Get(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Summary_Image::set_encoded_image_string(const ::std::string& value) {
  
  encoded_image_string_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set:tensorflow.Summary.Image.encoded_image_string)
}
inline void Summary_Image::set_encoded_image_string(const char* value) {
  
  encoded_image_string_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_char:tensorflow.Summary.Image.encoded_image_string)
}
inline void Summary_Image::set_encoded_image_string(const void* value,
    size_t size) {
  
  encoded_image_string_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_pointer:tensorflow.Summary.Image.encoded_image_string)
}
inline ::std::string* Summary_Image::mutable_encoded_image_string() {
  
  // @@protoc_insertion_point(field_mutable:tensorflow.Summary.Image.encoded_image_string)
  return encoded_image_string_.Mutable(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline ::std::string* Summary_Image::release_encoded_image_string() {
  // @@protoc_insertion_point(field_release:tensorflow.Summary.Image.encoded_image_string)
  
  return encoded_image_string_.Release(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline ::std::string* Summary_Image::unsafe_arena_release_encoded_image_string() {
  // @@protoc_insertion_point(field_unsafe_arena_release:tensorflow.Summary.Image.encoded_image_string)
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  
  return encoded_image_string_.UnsafeArenaRelease(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      GetArenaNoVirtual());
}
inline void Summary_Image::set_allocated_encoded_image_string(::std::string* encoded_image_string) {
  if (encoded_image_string != NULL) {
    
  } else {
    
  }
  encoded_image_string_.SetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), encoded_image_string,
      GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_allocated:tensorflow.Summary.Image.encoded_image_string)
}
inline void Summary_Image::unsafe_arena_set_allocated_encoded_image_string(
    ::std::string* encoded_image_string) {
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  if (encoded_image_string != NULL) {
    
  } else {
    
  }
  encoded_image_string_.UnsafeArenaSetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      encoded_image_string, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tensorflow.Summary.Image.encoded_image_string)
}

inline const Summary_Image* Summary_Image::internal_default_instance() {
  return &Summary_Image_default_instance_.get();
}
// -------------------------------------------------------------------

// Summary_Audio

// optional float sample_rate = 1;
inline void Summary_Audio::clear_sample_rate() {
  sample_rate_ = 0;
}
inline float Summary_Audio::sample_rate() const {
  // @@protoc_insertion_point(field_get:tensorflow.Summary.Audio.sample_rate)
  return sample_rate_;
}
inline void Summary_Audio::set_sample_rate(float value) {
  
  sample_rate_ = value;
  // @@protoc_insertion_point(field_set:tensorflow.Summary.Audio.sample_rate)
}

// optional int64 num_channels = 2;
inline void Summary_Audio::clear_num_channels() {
  num_channels_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 Summary_Audio::num_channels() const {
  // @@protoc_insertion_point(field_get:tensorflow.Summary.Audio.num_channels)
  return num_channels_;
}
inline void Summary_Audio::set_num_channels(::google::protobuf::int64 value) {
  
  num_channels_ = value;
  // @@protoc_insertion_point(field_set:tensorflow.Summary.Audio.num_channels)
}

// optional int64 length_frames = 3;
inline void Summary_Audio::clear_length_frames() {
  length_frames_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 Summary_Audio::length_frames() const {
  // @@protoc_insertion_point(field_get:tensorflow.Summary.Audio.length_frames)
  return length_frames_;
}
inline void Summary_Audio::set_length_frames(::google::protobuf::int64 value) {
  
  length_frames_ = value;
  // @@protoc_insertion_point(field_set:tensorflow.Summary.Audio.length_frames)
}

// optional bytes encoded_audio_string = 4;
inline void Summary_Audio::clear_encoded_audio_string() {
  encoded_audio_string_.ClearToEmpty(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline const ::std::string& Summary_Audio::encoded_audio_string() const {
  // @@protoc_insertion_point(field_get:tensorflow.Summary.Audio.encoded_audio_string)
  return encoded_audio_string_.Get(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Summary_Audio::set_encoded_audio_string(const ::std::string& value) {
  
  encoded_audio_string_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set:tensorflow.Summary.Audio.encoded_audio_string)
}
inline void Summary_Audio::set_encoded_audio_string(const char* value) {
  
  encoded_audio_string_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_char:tensorflow.Summary.Audio.encoded_audio_string)
}
inline void Summary_Audio::set_encoded_audio_string(const void* value,
    size_t size) {
  
  encoded_audio_string_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_pointer:tensorflow.Summary.Audio.encoded_audio_string)
}
inline ::std::string* Summary_Audio::mutable_encoded_audio_string() {
  
  // @@protoc_insertion_point(field_mutable:tensorflow.Summary.Audio.encoded_audio_string)
  return encoded_audio_string_.Mutable(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline ::std::string* Summary_Audio::release_encoded_audio_string() {
  // @@protoc_insertion_point(field_release:tensorflow.Summary.Audio.encoded_audio_string)
  
  return encoded_audio_string_.Release(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline ::std::string* Summary_Audio::unsafe_arena_release_encoded_audio_string() {
  // @@protoc_insertion_point(field_unsafe_arena_release:tensorflow.Summary.Audio.encoded_audio_string)
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  
  return encoded_audio_string_.UnsafeArenaRelease(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      GetArenaNoVirtual());
}
inline void Summary_Audio::set_allocated_encoded_audio_string(::std::string* encoded_audio_string) {
  if (encoded_audio_string != NULL) {
    
  } else {
    
  }
  encoded_audio_string_.SetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), encoded_audio_string,
      GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_allocated:tensorflow.Summary.Audio.encoded_audio_string)
}
inline void Summary_Audio::unsafe_arena_set_allocated_encoded_audio_string(
    ::std::string* encoded_audio_string) {
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  if (encoded_audio_string != NULL) {
    
  } else {
    
  }
  encoded_audio_string_.UnsafeArenaSetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      encoded_audio_string, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tensorflow.Summary.Audio.encoded_audio_string)
}

// optional string content_type = 5;
inline void Summary_Audio::clear_content_type() {
  content_type_.ClearToEmpty(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline const ::std::string& Summary_Audio::content_type() const {
  // @@protoc_insertion_point(field_get:tensorflow.Summary.Audio.content_type)
  return content_type_.Get(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Summary_Audio::set_content_type(const ::std::string& value) {
  
  content_type_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set:tensorflow.Summary.Audio.content_type)
}
inline void Summary_Audio::set_content_type(const char* value) {
  
  content_type_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_char:tensorflow.Summary.Audio.content_type)
}
inline void Summary_Audio::set_content_type(const char* value,
    size_t size) {
  
  content_type_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_pointer:tensorflow.Summary.Audio.content_type)
}
inline ::std::string* Summary_Audio::mutable_content_type() {
  
  // @@protoc_insertion_point(field_mutable:tensorflow.Summary.Audio.content_type)
  return content_type_.Mutable(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline ::std::string* Summary_Audio::release_content_type() {
  // @@protoc_insertion_point(field_release:tensorflow.Summary.Audio.content_type)
  
  return content_type_.Release(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline ::std::string* Summary_Audio::unsafe_arena_release_content_type() {
  // @@protoc_insertion_point(field_unsafe_arena_release:tensorflow.Summary.Audio.content_type)
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  
  return content_type_.UnsafeArenaRelease(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      GetArenaNoVirtual());
}
inline void Summary_Audio::set_allocated_content_type(::std::string* content_type) {
  if (content_type != NULL) {
    
  } else {
    
  }
  content_type_.SetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), content_type,
      GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_allocated:tensorflow.Summary.Audio.content_type)
}
inline void Summary_Audio::unsafe_arena_set_allocated_content_type(
    ::std::string* content_type) {
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  if (content_type != NULL) {
    
  } else {
    
  }
  content_type_.UnsafeArenaSetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      content_type, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tensorflow.Summary.Audio.content_type)
}

inline const Summary_Audio* Summary_Audio::internal_default_instance() {
  return &Summary_Audio_default_instance_.get();
}
// -------------------------------------------------------------------

// Summary_Value

// optional string node_name = 7;
inline void Summary_Value::clear_node_name() {
  node_name_.ClearToEmpty(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline const ::std::string& Summary_Value::node_name() const {
  // @@protoc_insertion_point(field_get:tensorflow.Summary.Value.node_name)
  return node_name_.Get(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Summary_Value::set_node_name(const ::std::string& value) {
  
  node_name_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set:tensorflow.Summary.Value.node_name)
}
inline void Summary_Value::set_node_name(const char* value) {
  
  node_name_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_char:tensorflow.Summary.Value.node_name)
}
inline void Summary_Value::set_node_name(const char* value,
    size_t size) {
  
  node_name_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_pointer:tensorflow.Summary.Value.node_name)
}
inline ::std::string* Summary_Value::mutable_node_name() {
  
  // @@protoc_insertion_point(field_mutable:tensorflow.Summary.Value.node_name)
  return node_name_.Mutable(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline ::std::string* Summary_Value::release_node_name() {
  // @@protoc_insertion_point(field_release:tensorflow.Summary.Value.node_name)
  
  return node_name_.Release(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline ::std::string* Summary_Value::unsafe_arena_release_node_name() {
  // @@protoc_insertion_point(field_unsafe_arena_release:tensorflow.Summary.Value.node_name)
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  
  return node_name_.UnsafeArenaRelease(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      GetArenaNoVirtual());
}
inline void Summary_Value::set_allocated_node_name(::std::string* node_name) {
  if (node_name != NULL) {
    
  } else {
    
  }
  node_name_.SetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), node_name,
      GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_allocated:tensorflow.Summary.Value.node_name)
}
inline void Summary_Value::unsafe_arena_set_allocated_node_name(
    ::std::string* node_name) {
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  if (node_name != NULL) {
    
  } else {
    
  }
  node_name_.UnsafeArenaSetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      node_name, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tensorflow.Summary.Value.node_name)
}

// optional string tag = 1;
inline void Summary_Value::clear_tag() {
  tag_.ClearToEmpty(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline const ::std::string& Summary_Value::tag() const {
  // @@protoc_insertion_point(field_get:tensorflow.Summary.Value.tag)
  return tag_.Get(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Summary_Value::set_tag(const ::std::string& value) {
  
  tag_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set:tensorflow.Summary.Value.tag)
}
inline void Summary_Value::set_tag(const char* value) {
  
  tag_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_char:tensorflow.Summary.Value.tag)
}
inline void Summary_Value::set_tag(const char* value,
    size_t size) {
  
  tag_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_pointer:tensorflow.Summary.Value.tag)
}
inline ::std::string* Summary_Value::mutable_tag() {
  
  // @@protoc_insertion_point(field_mutable:tensorflow.Summary.Value.tag)
  return tag_.Mutable(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline ::std::string* Summary_Value::release_tag() {
  // @@protoc_insertion_point(field_release:tensorflow.Summary.Value.tag)
  
  return tag_.Release(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline ::std::string* Summary_Value::unsafe_arena_release_tag() {
  // @@protoc_insertion_point(field_unsafe_arena_release:tensorflow.Summary.Value.tag)
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  
  return tag_.UnsafeArenaRelease(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      GetArenaNoVirtual());
}
inline void Summary_Value::set_allocated_tag(::std::string* tag) {
  if (tag != NULL) {
    
  } else {
    
  }
  tag_.SetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), tag,
      GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_allocated:tensorflow.Summary.Value.tag)
}
inline void Summary_Value::unsafe_arena_set_allocated_tag(
    ::std::string* tag) {
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  if (tag != NULL) {
    
  } else {
    
  }
  tag_.UnsafeArenaSetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      tag, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tensorflow.Summary.Value.tag)
}

// optional float simple_value = 2;
inline bool Summary_Value::has_simple_value() const {
  return value_case() == kSimpleValue;
}
inline void Summary_Value::set_has_simple_value() {
  _oneof_case_[0] = kSimpleValue;
}
inline void Summary_Value::clear_simple_value() {
  if (has_simple_value()) {
    value_.simple_value_ = 0;
    clear_has_value();
  }
}
inline float Summary_Value::simple_value() const {
  // @@protoc_insertion_point(field_get:tensorflow.Summary.Value.simple_value)
  if (has_simple_value()) {
    return value_.simple_value_;
  }
  return 0;
}
inline void Summary_Value::set_simple_value(float value) {
  if (!has_simple_value()) {
    clear_value();
    set_has_simple_value();
  }
  value_.simple_value_ = value;
  // @@protoc_insertion_point(field_set:tensorflow.Summary.Value.simple_value)
}

// optional bytes obsolete_old_style_histogram = 3;
inline bool Summary_Value::has_obsolete_old_style_histogram() const {
  return value_case() == kObsoleteOldStyleHistogram;
}
inline void Summary_Value::set_has_obsolete_old_style_histogram() {
  _oneof_case_[0] = kObsoleteOldStyleHistogram;
}
inline void Summary_Value::clear_obsolete_old_style_histogram() {
  if (has_obsolete_old_style_histogram()) {
    value_.obsolete_old_style_histogram_.Destroy(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
        GetArenaNoVirtual());
    clear_has_value();
  }
}
inline const ::std::string& Summary_Value::obsolete_old_style_histogram() const {
  // @@protoc_insertion_point(field_get:tensorflow.Summary.Value.obsolete_old_style_histogram)
  if (has_obsolete_old_style_histogram()) {
    return value_.obsolete_old_style_histogram_.Get(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  return *&::google::protobuf::internal::GetEmptyStringAlreadyInited();
}
inline void Summary_Value::set_obsolete_old_style_histogram(const ::std::string& value) {
  if (!has_obsolete_old_style_histogram()) {
    clear_value();
    set_has_obsolete_old_style_histogram();
    value_.obsolete_old_style_histogram_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  value_.obsolete_old_style_histogram_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value,
      GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set:tensorflow.Summary.Value.obsolete_old_style_histogram)
}
inline void Summary_Value::set_obsolete_old_style_histogram(const char* value) {
  if (!has_obsolete_old_style_histogram()) {
    clear_value();
    set_has_obsolete_old_style_histogram();
    value_.obsolete_old_style_histogram_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  value_.obsolete_old_style_histogram_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(value), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_char:tensorflow.Summary.Value.obsolete_old_style_histogram)
}
inline void Summary_Value::set_obsolete_old_style_histogram(const void* value,
                             size_t size) {
  if (!has_obsolete_old_style_histogram()) {
    clear_value();
    set_has_obsolete_old_style_histogram();
    value_.obsolete_old_style_histogram_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  value_.obsolete_old_style_histogram_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size),
      GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_pointer:tensorflow.Summary.Value.obsolete_old_style_histogram)
}
inline ::std::string* Summary_Value::mutable_obsolete_old_style_histogram() {
  if (!has_obsolete_old_style_histogram()) {
    clear_value();
    set_has_obsolete_old_style_histogram();
    value_.obsolete_old_style_histogram_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  return value_.obsolete_old_style_histogram_.Mutable(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      GetArenaNoVirtual());
  // @@protoc_insertion_point(field_mutable:tensorflow.Summary.Value.obsolete_old_style_histogram)
}
inline ::std::string* Summary_Value::release_obsolete_old_style_histogram() {
  // @@protoc_insertion_point(field_release:tensorflow.Summary.Value.obsolete_old_style_histogram)
  if (has_obsolete_old_style_histogram()) {
    clear_has_value();
    return value_.obsolete_old_style_histogram_.Release(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
        GetArenaNoVirtual());
  } else {
    return NULL;
  }
}
inline ::std::string* Summary_Value::unsafe_arena_release_obsolete_old_style_histogram() {
  // @@protoc_insertion_point(field_unsafe_arena_release:tensorflow.Summary.Value.obsolete_old_style_histogram)
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  if (has_obsolete_old_style_histogram()) {
    clear_has_value();
    return value_.obsolete_old_style_histogram_.UnsafeArenaRelease(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
  } else {
    return NULL;
  }
}
inline void Summary_Value::set_allocated_obsolete_old_style_histogram(::std::string* obsolete_old_style_histogram) {
  if (!has_obsolete_old_style_histogram()) {
    value_.obsolete_old_style_histogram_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  clear_value();
  if (obsolete_old_style_histogram != NULL) {
    set_has_obsolete_old_style_histogram();
    value_.obsolete_old_style_histogram_.SetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), obsolete_old_style_histogram,
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_set_allocated:tensorflow.Summary.Value.obsolete_old_style_histogram)
}
inline void Summary_Value::unsafe_arena_set_allocated_obsolete_old_style_histogram(::std::string* obsolete_old_style_histogram) {
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  if (!has_obsolete_old_style_histogram()) {
    value_.obsolete_old_style_histogram_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  clear_value();
  if (obsolete_old_style_histogram) {
    set_has_obsolete_old_style_histogram();
    value_.obsolete_old_style_histogram_.UnsafeArenaSetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), obsolete_old_style_histogram, GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tensorflow.Summary.Value.obsolete_old_style_histogram)
}

// optional .tensorflow.Summary.Image image = 4;
inline bool Summary_Value::has_image() const {
  return value_case() == kImage;
}
inline void Summary_Value::set_has_image() {
  _oneof_case_[0] = kImage;
}
inline void Summary_Value::clear_image() {
  if (has_image()) {
    if (GetArenaNoVirtual() == NULL) {
      delete value_.image_;
    }
    clear_has_value();
  }
}
inline  const ::tensorflow::Summary_Image& Summary_Value::image() const {
  // @@protoc_insertion_point(field_get:tensorflow.Summary.Value.image)
  return has_image()
      ? *value_.image_
      : ::tensorflow::Summary_Image::default_instance();
}
inline ::tensorflow::Summary_Image* Summary_Value::mutable_image() {
  if (!has_image()) {
    clear_value();
    set_has_image();
    value_.image_ = 
      ::google::protobuf::Arena::CreateMessage< ::tensorflow::Summary_Image >(
      GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:tensorflow.Summary.Value.image)
  return value_.image_;
}
inline ::tensorflow::Summary_Image* Summary_Value::release_image() {
  // @@protoc_insertion_point(field_release:tensorflow.Summary.Value.image)
  if (has_image()) {
    clear_has_value();
    if (GetArenaNoVirtual() != NULL) {
      ::tensorflow::Summary_Image* temp = new ::tensorflow::Summary_Image(*value_.image_);
      value_.image_ = NULL;
      return temp;
    } else {
      ::tensorflow::Summary_Image* temp = value_.image_;
      value_.image_ = NULL;
      return temp;
    }
  } else {
    return NULL;
  }
}
inline void Summary_Value::set_allocated_image(::tensorflow::Summary_Image* image) {
  clear_value();
  if (image) {
    if (GetArenaNoVirtual() != NULL &&
        ::google::protobuf::Arena::GetArena(image) == NULL) {
      GetArenaNoVirtual()->Own(image);
    } else if (GetArenaNoVirtual() !=
               ::google::protobuf::Arena::GetArena(image)) {
      ::tensorflow::Summary_Image* new_image = 
          ::google::protobuf::Arena::CreateMessage< ::tensorflow::Summary_Image >(
          GetArenaNoVirtual());
      new_image->CopyFrom(*image);
      image = new_image;
    }
    set_has_image();
    value_.image_ = image;
  }
  // @@protoc_insertion_point(field_set_allocated:tensorflow.Summary.Value.image)
}
inline  ::tensorflow::Summary_Image* Summary_Value::unsafe_arena_release_image() {
  // @@protoc_insertion_point(field_unsafe_arena_release:tensorflow.Summary.Value.image)
  if (has_image()) {
    clear_has_value();
    ::tensorflow::Summary_Image* temp = value_.image_;
    value_.image_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline  void Summary_Value::unsafe_arena_set_allocated_image(::tensorflow::Summary_Image* image) {
  clear_value();
  if (image) {
    set_has_image();
    value_.image_ = image;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tensorflow.Summary.Value.image)
}

// optional .tensorflow.HistogramProto histo = 5;
inline bool Summary_Value::has_histo() const {
  return value_case() == kHisto;
}
inline void Summary_Value::set_has_histo() {
  _oneof_case_[0] = kHisto;
}
inline void Summary_Value::clear_histo() {
  if (has_histo()) {
    if (GetArenaNoVirtual() == NULL) {
      delete value_.histo_;
    }
    clear_has_value();
  }
}
inline  const ::tensorflow::HistogramProto& Summary_Value::histo() const {
  // @@protoc_insertion_point(field_get:tensorflow.Summary.Value.histo)
  return has_histo()
      ? *value_.histo_
      : ::tensorflow::HistogramProto::default_instance();
}
inline ::tensorflow::HistogramProto* Summary_Value::mutable_histo() {
  if (!has_histo()) {
    clear_value();
    set_has_histo();
    value_.histo_ = 
      ::google::protobuf::Arena::CreateMessage< ::tensorflow::HistogramProto >(
      GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:tensorflow.Summary.Value.histo)
  return value_.histo_;
}
inline ::tensorflow::HistogramProto* Summary_Value::release_histo() {
  // @@protoc_insertion_point(field_release:tensorflow.Summary.Value.histo)
  if (has_histo()) {
    clear_has_value();
    if (GetArenaNoVirtual() != NULL) {
      ::tensorflow::HistogramProto* temp = new ::tensorflow::HistogramProto(*value_.histo_);
      value_.histo_ = NULL;
      return temp;
    } else {
      ::tensorflow::HistogramProto* temp = value_.histo_;
      value_.histo_ = NULL;
      return temp;
    }
  } else {
    return NULL;
  }
}
inline void Summary_Value::set_allocated_histo(::tensorflow::HistogramProto* histo) {
  clear_value();
  if (histo) {
    if (GetArenaNoVirtual() != NULL &&
        ::google::protobuf::Arena::GetArena(histo) == NULL) {
      GetArenaNoVirtual()->Own(histo);
    } else if (GetArenaNoVirtual() !=
               ::google::protobuf::Arena::GetArena(histo)) {
      ::tensorflow::HistogramProto* new_histo = 
          ::google::protobuf::Arena::CreateMessage< ::tensorflow::HistogramProto >(
          GetArenaNoVirtual());
      new_histo->CopyFrom(*histo);
      histo = new_histo;
    }
    set_has_histo();
    value_.histo_ = histo;
  }
  // @@protoc_insertion_point(field_set_allocated:tensorflow.Summary.Value.histo)
}
inline  ::tensorflow::HistogramProto* Summary_Value::unsafe_arena_release_histo() {
  // @@protoc_insertion_point(field_unsafe_arena_release:tensorflow.Summary.Value.histo)
  if (has_histo()) {
    clear_has_value();
    ::tensorflow::HistogramProto* temp = value_.histo_;
    value_.histo_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline  void Summary_Value::unsafe_arena_set_allocated_histo(::tensorflow::HistogramProto* histo) {
  clear_value();
  if (histo) {
    set_has_histo();
    value_.histo_ = histo;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tensorflow.Summary.Value.histo)
}

// optional .tensorflow.Summary.Audio audio = 6;
inline bool Summary_Value::has_audio() const {
  return value_case() == kAudio;
}
inline void Summary_Value::set_has_audio() {
  _oneof_case_[0] = kAudio;
}
inline void Summary_Value::clear_audio() {
  if (has_audio()) {
    if (GetArenaNoVirtual() == NULL) {
      delete value_.audio_;
    }
    clear_has_value();
  }
}
inline  const ::tensorflow::Summary_Audio& Summary_Value::audio() const {
  // @@protoc_insertion_point(field_get:tensorflow.Summary.Value.audio)
  return has_audio()
      ? *value_.audio_
      : ::tensorflow::Summary_Audio::default_instance();
}
inline ::tensorflow::Summary_Audio* Summary_Value::mutable_audio() {
  if (!has_audio()) {
    clear_value();
    set_has_audio();
    value_.audio_ = 
      ::google::protobuf::Arena::CreateMessage< ::tensorflow::Summary_Audio >(
      GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:tensorflow.Summary.Value.audio)
  return value_.audio_;
}
inline ::tensorflow::Summary_Audio* Summary_Value::release_audio() {
  // @@protoc_insertion_point(field_release:tensorflow.Summary.Value.audio)
  if (has_audio()) {
    clear_has_value();
    if (GetArenaNoVirtual() != NULL) {
      ::tensorflow::Summary_Audio* temp = new ::tensorflow::Summary_Audio(*value_.audio_);
      value_.audio_ = NULL;
      return temp;
    } else {
      ::tensorflow::Summary_Audio* temp = value_.audio_;
      value_.audio_ = NULL;
      return temp;
    }
  } else {
    return NULL;
  }
}
inline void Summary_Value::set_allocated_audio(::tensorflow::Summary_Audio* audio) {
  clear_value();
  if (audio) {
    if (GetArenaNoVirtual() != NULL &&
        ::google::protobuf::Arena::GetArena(audio) == NULL) {
      GetArenaNoVirtual()->Own(audio);
    } else if (GetArenaNoVirtual() !=
               ::google::protobuf::Arena::GetArena(audio)) {
      ::tensorflow::Summary_Audio* new_audio = 
          ::google::protobuf::Arena::CreateMessage< ::tensorflow::Summary_Audio >(
          GetArenaNoVirtual());
      new_audio->CopyFrom(*audio);
      audio = new_audio;
    }
    set_has_audio();
    value_.audio_ = audio;
  }
  // @@protoc_insertion_point(field_set_allocated:tensorflow.Summary.Value.audio)
}
inline  ::tensorflow::Summary_Audio* Summary_Value::unsafe_arena_release_audio() {
  // @@protoc_insertion_point(field_unsafe_arena_release:tensorflow.Summary.Value.audio)
  if (has_audio()) {
    clear_has_value();
    ::tensorflow::Summary_Audio* temp = value_.audio_;
    value_.audio_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline  void Summary_Value::unsafe_arena_set_allocated_audio(::tensorflow::Summary_Audio* audio) {
  clear_value();
  if (audio) {
    set_has_audio();
    value_.audio_ = audio;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tensorflow.Summary.Value.audio)
}

// optional .tensorflow.TensorProto tensor = 8;
inline bool Summary_Value::has_tensor() const {
  return value_case() == kTensor;
}
inline void Summary_Value::set_has_tensor() {
  _oneof_case_[0] = kTensor;
}
inline void Summary_Value::clear_tensor() {
  if (has_tensor()) {
    if (GetArenaNoVirtual() == NULL) {
      delete value_.tensor_;
    }
    clear_has_value();
  }
}
inline  const ::tensorflow::TensorProto& Summary_Value::tensor() const {
  // @@protoc_insertion_point(field_get:tensorflow.Summary.Value.tensor)
  return has_tensor()
      ? *value_.tensor_
      : ::tensorflow::TensorProto::default_instance();
}
inline ::tensorflow::TensorProto* Summary_Value::mutable_tensor() {
  if (!has_tensor()) {
    clear_value();
    set_has_tensor();
    value_.tensor_ = 
      ::google::protobuf::Arena::CreateMessage< ::tensorflow::TensorProto >(
      GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:tensorflow.Summary.Value.tensor)
  return value_.tensor_;
}
inline ::tensorflow::TensorProto* Summary_Value::release_tensor() {
  // @@protoc_insertion_point(field_release:tensorflow.Summary.Value.tensor)
  if (has_tensor()) {
    clear_has_value();
    if (GetArenaNoVirtual() != NULL) {
      ::tensorflow::TensorProto* temp = new ::tensorflow::TensorProto(*value_.tensor_);
      value_.tensor_ = NULL;
      return temp;
    } else {
      ::tensorflow::TensorProto* temp = value_.tensor_;
      value_.tensor_ = NULL;
      return temp;
    }
  } else {
    return NULL;
  }
}
inline void Summary_Value::set_allocated_tensor(::tensorflow::TensorProto* tensor) {
  clear_value();
  if (tensor) {
    if (GetArenaNoVirtual() != NULL &&
        ::google::protobuf::Arena::GetArena(tensor) == NULL) {
      GetArenaNoVirtual()->Own(tensor);
    } else if (GetArenaNoVirtual() !=
               ::google::protobuf::Arena::GetArena(tensor)) {
      ::tensorflow::TensorProto* new_tensor = 
          ::google::protobuf::Arena::CreateMessage< ::tensorflow::TensorProto >(
          GetArenaNoVirtual());
      new_tensor->CopyFrom(*tensor);
      tensor = new_tensor;
    }
    set_has_tensor();
    value_.tensor_ = tensor;
  }
  // @@protoc_insertion_point(field_set_allocated:tensorflow.Summary.Value.tensor)
}
inline  ::tensorflow::TensorProto* Summary_Value::unsafe_arena_release_tensor() {
  // @@protoc_insertion_point(field_unsafe_arena_release:tensorflow.Summary.Value.tensor)
  if (has_tensor()) {
    clear_has_value();
    ::tensorflow::TensorProto* temp = value_.tensor_;
    value_.tensor_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline  void Summary_Value::unsafe_arena_set_allocated_tensor(::tensorflow::TensorProto* tensor) {
  clear_value();
  if (tensor) {
    set_has_tensor();
    value_.tensor_ = tensor;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tensorflow.Summary.Value.tensor)
}

inline bool Summary_Value::has_value() const {
  return value_case() != VALUE_NOT_SET;
}
inline void Summary_Value::clear_has_value() {
  _oneof_case_[0] = VALUE_NOT_SET;
}
inline Summary_Value::ValueCase Summary_Value::value_case() const {
  return Summary_Value::ValueCase(_oneof_case_[0]);
}
inline const Summary_Value* Summary_Value::internal_default_instance() {
  return &Summary_Value_default_instance_.get();
}
// -------------------------------------------------------------------

// Summary

// repeated .tensorflow.Summary.Value value = 1;
inline int Summary::value_size() const {
  return value_.size();
}
inline void Summary::clear_value() {
  value_.Clear();
}
inline const ::tensorflow::Summary_Value& Summary::value(int index) const {
  // @@protoc_insertion_point(field_get:tensorflow.Summary.value)
  return value_.Get(index);
}
inline ::tensorflow::Summary_Value* Summary::mutable_value(int index) {
  // @@protoc_insertion_point(field_mutable:tensorflow.Summary.value)
  return value_.Mutable(index);
}
inline ::tensorflow::Summary_Value* Summary::add_value() {
  // @@protoc_insertion_point(field_add:tensorflow.Summary.value)
  return value_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::tensorflow::Summary_Value >*
Summary::mutable_value() {
  // @@protoc_insertion_point(field_mutable_list:tensorflow.Summary.value)
  return &value_;
}
inline const ::google::protobuf::RepeatedPtrField< ::tensorflow::Summary_Value >&
Summary::value() const {
  // @@protoc_insertion_point(field_list:tensorflow.Summary.value)
  return value_;
}

inline const Summary* Summary::internal_default_instance() {
  return &Summary_default_instance_.get();
}
// -------------------------------------------------------------------

// AttrValue_ListValue

// repeated bytes s = 2;
inline int AttrValue_ListValue::s_size() const {
  return s_.size();
}
inline void AttrValue_ListValue::clear_s() {
  s_.Clear();
}
inline const ::std::string& AttrValue_ListValue::s(int index) const {
  // @@protoc_insertion_point(field_get:tensorflow.AttrValue.ListValue.s)
  return s_.Get(index);
}
inline ::std::string* AttrValue_ListValue::mutable_s(int index) {
  // @@protoc_insertion_point(field_mutable:tensorflow.AttrValue.ListValue.s)
  return s_.Mutable(index);
}
inline void AttrValue_ListValue::set_s(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:tensorflow.AttrValue.ListValue.s)
  s_.Mutable(index)->assign(value);
}
inline void AttrValue_ListValue::set_s(int index, const char* value) {
  s_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:tensorflow.AttrValue.ListValue.s)
}
inline void AttrValue_ListValue::set_s(int index, const void* value, size_t size) {
  s_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:tensorflow.AttrValue.ListValue.s)
}
inline ::std::string* AttrValue_ListValue::add_s() {
  // @@protoc_insertion_point(field_add_mutable:tensorflow.AttrValue.ListValue.s)
  return s_.Add();
}
inline void AttrValue_ListValue::add_s(const ::std::string& value) {
  s_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:tensorflow.AttrValue.ListValue.s)
}
inline void AttrValue_ListValue::add_s(const char* value) {
  s_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:tensorflow.AttrValue.ListValue.s)
}
inline void AttrValue_ListValue::add_s(const void* value, size_t size) {
  s_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:tensorflow.AttrValue.ListValue.s)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
AttrValue_ListValue::s() const {
  // @@protoc_insertion_point(field_list:tensorflow.AttrValue.ListValue.s)
  return s_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
AttrValue_ListValue::mutable_s() {
  // @@protoc_insertion_point(field_mutable_list:tensorflow.AttrValue.ListValue.s)
  return &s_;
}

// repeated int64 i = 3 [packed = true];
inline int AttrValue_ListValue::i_size() const {
  return i_.size();
}
inline void AttrValue_ListValue::clear_i() {
  i_.Clear();
}
inline ::google::protobuf::int64 AttrValue_ListValue::i(int index) const {
  // @@protoc_insertion_point(field_get:tensorflow.AttrValue.ListValue.i)
  return i_.Get(index);
}
inline void AttrValue_ListValue::set_i(int index, ::google::protobuf::int64 value) {
  i_.Set(index, value);
  // @@protoc_insertion_point(field_set:tensorflow.AttrValue.ListValue.i)
}
inline void AttrValue_ListValue::add_i(::google::protobuf::int64 value) {
  i_.Add(value);
  // @@protoc_insertion_point(field_add:tensorflow.AttrValue.ListValue.i)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int64 >&
AttrValue_ListValue::i() const {
  // @@protoc_insertion_point(field_list:tensorflow.AttrValue.ListValue.i)
  return i_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int64 >*
AttrValue_ListValue::mutable_i() {
  // @@protoc_insertion_point(field_mutable_list:tensorflow.AttrValue.ListValue.i)
  return &i_;
}

// repeated float f = 4 [packed = true];
inline int AttrValue_ListValue::f_size() const {
  return f_.size();
}
inline void AttrValue_ListValue::clear_f() {
  f_.Clear();
}
inline float AttrValue_ListValue::f(int index) const {
  // @@protoc_insertion_point(field_get:tensorflow.AttrValue.ListValue.f)
  return f_.Get(index);
}
inline void AttrValue_ListValue::set_f(int index, float value) {
  f_.Set(index, value);
  // @@protoc_insertion_point(field_set:tensorflow.AttrValue.ListValue.f)
}
inline void AttrValue_ListValue::add_f(float value) {
  f_.Add(value);
  // @@protoc_insertion_point(field_add:tensorflow.AttrValue.ListValue.f)
}
inline const ::google::protobuf::RepeatedField< float >&
AttrValue_ListValue::f() const {
  // @@protoc_insertion_point(field_list:tensorflow.AttrValue.ListValue.f)
  return f_;
}
inline ::google::protobuf::RepeatedField< float >*
AttrValue_ListValue::mutable_f() {
  // @@protoc_insertion_point(field_mutable_list:tensorflow.AttrValue.ListValue.f)
  return &f_;
}

// repeated bool b = 5 [packed = true];
inline int AttrValue_ListValue::b_size() const {
  return b_.size();
}
inline void AttrValue_ListValue::clear_b() {
  b_.Clear();
}
inline bool AttrValue_ListValue::b(int index) const {
  // @@protoc_insertion_point(field_get:tensorflow.AttrValue.ListValue.b)
  return b_.Get(index);
}
inline void AttrValue_ListValue::set_b(int index, bool value) {
  b_.Set(index, value);
  // @@protoc_insertion_point(field_set:tensorflow.AttrValue.ListValue.b)
}
inline void AttrValue_ListValue::add_b(bool value) {
  b_.Add(value);
  // @@protoc_insertion_point(field_add:tensorflow.AttrValue.ListValue.b)
}
inline const ::google::protobuf::RepeatedField< bool >&
AttrValue_ListValue::b() const {
  // @@protoc_insertion_point(field_list:tensorflow.AttrValue.ListValue.b)
  return b_;
}
inline ::google::protobuf::RepeatedField< bool >*
AttrValue_ListValue::mutable_b() {
  // @@protoc_insertion_point(field_mutable_list:tensorflow.AttrValue.ListValue.b)
  return &b_;
}

// repeated .tensorflow.DataType type = 6 [packed = true];
inline int AttrValue_ListValue::type_size() const {
  return type_.size();
}
inline void AttrValue_ListValue::clear_type() {
  type_.Clear();
}
inline ::tensorflow::DataType AttrValue_ListValue::type(int index) const {
  // @@protoc_insertion_point(field_get:tensorflow.AttrValue.ListValue.type)
  return static_cast< ::tensorflow::DataType >(type_.Get(index));
}
inline void AttrValue_ListValue::set_type(int index, ::tensorflow::DataType value) {
  type_.Set(index, value);
  // @@protoc_insertion_point(field_set:tensorflow.AttrValue.ListValue.type)
}
inline void AttrValue_ListValue::add_type(::tensorflow::DataType value) {
  type_.Add(value);
  // @@protoc_insertion_point(field_add:tensorflow.AttrValue.ListValue.type)
}
inline const ::google::protobuf::RepeatedField<int>&
AttrValue_ListValue::type() const {
  // @@protoc_insertion_point(field_list:tensorflow.AttrValue.ListValue.type)
  return type_;
}
inline ::google::protobuf::RepeatedField<int>*
AttrValue_ListValue::mutable_type() {
  // @@protoc_insertion_point(field_mutable_list:tensorflow.AttrValue.ListValue.type)
  return &type_;
}

// repeated .tensorflow.TensorShapeProto shape = 7;
inline int AttrValue_ListValue::shape_size() const {
  return shape_.size();
}
inline void AttrValue_ListValue::clear_shape() {
  shape_.Clear();
}
inline const ::tensorflow::TensorShapeProto& AttrValue_ListValue::shape(int index) const {
  // @@protoc_insertion_point(field_get:tensorflow.AttrValue.ListValue.shape)
  return shape_.Get(index);
}
inline ::tensorflow::TensorShapeProto* AttrValue_ListValue::mutable_shape(int index) {
  // @@protoc_insertion_point(field_mutable:tensorflow.AttrValue.ListValue.shape)
  return shape_.Mutable(index);
}
inline ::tensorflow::TensorShapeProto* AttrValue_ListValue::add_shape() {
  // @@protoc_insertion_point(field_add:tensorflow.AttrValue.ListValue.shape)
  return shape_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::tensorflow::TensorShapeProto >*
AttrValue_ListValue::mutable_shape() {
  // @@protoc_insertion_point(field_mutable_list:tensorflow.AttrValue.ListValue.shape)
  return &shape_;
}
inline const ::google::protobuf::RepeatedPtrField< ::tensorflow::TensorShapeProto >&
AttrValue_ListValue::shape() const {
  // @@protoc_insertion_point(field_list:tensorflow.AttrValue.ListValue.shape)
  return shape_;
}

// repeated .tensorflow.TensorProto tensor = 8;
inline int AttrValue_ListValue::tensor_size() const {
  return tensor_.size();
}
inline void AttrValue_ListValue::clear_tensor() {
  tensor_.Clear();
}
inline const ::tensorflow::TensorProto& AttrValue_ListValue::tensor(int index) const {
  // @@protoc_insertion_point(field_get:tensorflow.AttrValue.ListValue.tensor)
  return tensor_.Get(index);
}
inline ::tensorflow::TensorProto* AttrValue_ListValue::mutable_tensor(int index) {
  // @@protoc_insertion_point(field_mutable:tensorflow.AttrValue.ListValue.tensor)
  return tensor_.Mutable(index);
}
inline ::tensorflow::TensorProto* AttrValue_ListValue::add_tensor() {
  // @@protoc_insertion_point(field_add:tensorflow.AttrValue.ListValue.tensor)
  return tensor_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::tensorflow::TensorProto >*
AttrValue_ListValue::mutable_tensor() {
  // @@protoc_insertion_point(field_mutable_list:tensorflow.AttrValue.ListValue.tensor)
  return &tensor_;
}
inline const ::google::protobuf::RepeatedPtrField< ::tensorflow::TensorProto >&
AttrValue_ListValue::tensor() const {
  // @@protoc_insertion_point(field_list:tensorflow.AttrValue.ListValue.tensor)
  return tensor_;
}

inline const AttrValue_ListValue* AttrValue_ListValue::internal_default_instance() {
  return &AttrValue_ListValue_default_instance_.get();
}
// -------------------------------------------------------------------

// AttrValue

// optional bytes s = 2;
inline bool AttrValue::has_s() const {
  return value_case() == kS;
}
inline void AttrValue::set_has_s() {
  _oneof_case_[0] = kS;
}
inline void AttrValue::clear_s() {
  if (has_s()) {
    value_.s_.Destroy(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
        GetArenaNoVirtual());
    clear_has_value();
  }
}
inline const ::std::string& AttrValue::s() const {
  // @@protoc_insertion_point(field_get:tensorflow.AttrValue.s)
  if (has_s()) {
    return value_.s_.Get(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  return *&::google::protobuf::internal::GetEmptyStringAlreadyInited();
}
inline void AttrValue::set_s(const ::std::string& value) {
  if (!has_s()) {
    clear_value();
    set_has_s();
    value_.s_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  value_.s_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value,
      GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set:tensorflow.AttrValue.s)
}
inline void AttrValue::set_s(const char* value) {
  if (!has_s()) {
    clear_value();
    set_has_s();
    value_.s_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  value_.s_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(value), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_char:tensorflow.AttrValue.s)
}
inline void AttrValue::set_s(const void* value,
                             size_t size) {
  if (!has_s()) {
    clear_value();
    set_has_s();
    value_.s_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  value_.s_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size),
      GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_pointer:tensorflow.AttrValue.s)
}
inline ::std::string* AttrValue::mutable_s() {
  if (!has_s()) {
    clear_value();
    set_has_s();
    value_.s_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  return value_.s_.Mutable(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      GetArenaNoVirtual());
  // @@protoc_insertion_point(field_mutable:tensorflow.AttrValue.s)
}
inline ::std::string* AttrValue::release_s() {
  // @@protoc_insertion_point(field_release:tensorflow.AttrValue.s)
  if (has_s()) {
    clear_has_value();
    return value_.s_.Release(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
        GetArenaNoVirtual());
  } else {
    return NULL;
  }
}
inline ::std::string* AttrValue::unsafe_arena_release_s() {
  // @@protoc_insertion_point(field_unsafe_arena_release:tensorflow.AttrValue.s)
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  if (has_s()) {
    clear_has_value();
    return value_.s_.UnsafeArenaRelease(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
  } else {
    return NULL;
  }
}
inline void AttrValue::set_allocated_s(::std::string* s) {
  if (!has_s()) {
    value_.s_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  clear_value();
  if (s != NULL) {
    set_has_s();
    value_.s_.SetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), s,
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_set_allocated:tensorflow.AttrValue.s)
}
inline void AttrValue::unsafe_arena_set_allocated_s(::std::string* s) {
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  if (!has_s()) {
    value_.s_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  clear_value();
  if (s) {
    set_has_s();
    value_.s_.UnsafeArenaSetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), s, GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tensorflow.AttrValue.s)
}

// optional int64 i = 3;
inline bool AttrValue::has_i() const {
  return value_case() == kI;
}
inline void AttrValue::set_has_i() {
  _oneof_case_[0] = kI;
}
inline void AttrValue::clear_i() {
  if (has_i()) {
    value_.i_ = GOOGLE_LONGLONG(0);
    clear_has_value();
  }
}
inline ::google::protobuf::int64 AttrValue::i() const {
  // @@protoc_insertion_point(field_get:tensorflow.AttrValue.i)
  if (has_i()) {
    return value_.i_;
  }
  return GOOGLE_LONGLONG(0);
}
inline void AttrValue::set_i(::google::protobuf::int64 value) {
  if (!has_i()) {
    clear_value();
    set_has_i();
  }
  value_.i_ = value;
  // @@protoc_insertion_point(field_set:tensorflow.AttrValue.i)
}

// optional float f = 4;
inline bool AttrValue::has_f() const {
  return value_case() == kF;
}
inline void AttrValue::set_has_f() {
  _oneof_case_[0] = kF;
}
inline void AttrValue::clear_f() {
  if (has_f()) {
    value_.f_ = 0;
    clear_has_value();
  }
}
inline float AttrValue::f() const {
  // @@protoc_insertion_point(field_get:tensorflow.AttrValue.f)
  if (has_f()) {
    return value_.f_;
  }
  return 0;
}
inline void AttrValue::set_f(float value) {
  if (!has_f()) {
    clear_value();
    set_has_f();
  }
  value_.f_ = value;
  // @@protoc_insertion_point(field_set:tensorflow.AttrValue.f)
}

// optional bool b = 5;
inline bool AttrValue::has_b() const {
  return value_case() == kB;
}
inline void AttrValue::set_has_b() {
  _oneof_case_[0] = kB;
}
inline void AttrValue::clear_b() {
  if (has_b()) {
    value_.b_ = false;
    clear_has_value();
  }
}
inline bool AttrValue::b() const {
  // @@protoc_insertion_point(field_get:tensorflow.AttrValue.b)
  if (has_b()) {
    return value_.b_;
  }
  return false;
}
inline void AttrValue::set_b(bool value) {
  if (!has_b()) {
    clear_value();
    set_has_b();
  }
  value_.b_ = value;
  // @@protoc_insertion_point(field_set:tensorflow.AttrValue.b)
}

// optional .tensorflow.DataType type = 6;
inline bool AttrValue::has_type() const {
  return value_case() == kType;
}
inline void AttrValue::set_has_type() {
  _oneof_case_[0] = kType;
}
inline void AttrValue::clear_type() {
  if (has_type()) {
    value_.type_ = 0;
    clear_has_value();
  }
}
inline ::tensorflow::DataType AttrValue::type() const {
  // @@protoc_insertion_point(field_get:tensorflow.AttrValue.type)
  if (has_type()) {
    return static_cast< ::tensorflow::DataType >(value_.type_);
  }
  return static_cast< ::tensorflow::DataType >(0);
}
inline void AttrValue::set_type(::tensorflow::DataType value) {
  if (!has_type()) {
    clear_value();
    set_has_type();
  }
  value_.type_ = value;
  // @@protoc_insertion_point(field_set:tensorflow.AttrValue.type)
}

// optional .tensorflow.TensorShapeProto shape = 7;
inline bool AttrValue::has_shape() const {
  return value_case() == kShape;
}
inline void AttrValue::set_has_shape() {
  _oneof_case_[0] = kShape;
}
inline void AttrValue::clear_shape() {
  if (has_shape()) {
    if (GetArenaNoVirtual() == NULL) {
      delete value_.shape_;
    }
    clear_has_value();
  }
}
inline  const ::tensorflow::TensorShapeProto& AttrValue::shape() const {
  // @@protoc_insertion_point(field_get:tensorflow.AttrValue.shape)
  return has_shape()
      ? *value_.shape_
      : ::tensorflow::TensorShapeProto::default_instance();
}
inline ::tensorflow::TensorShapeProto* AttrValue::mutable_shape() {
  if (!has_shape()) {
    clear_value();
    set_has_shape();
    value_.shape_ = 
      ::google::protobuf::Arena::CreateMessage< ::tensorflow::TensorShapeProto >(
      GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:tensorflow.AttrValue.shape)
  return value_.shape_;
}
inline ::tensorflow::TensorShapeProto* AttrValue::release_shape() {
  // @@protoc_insertion_point(field_release:tensorflow.AttrValue.shape)
  if (has_shape()) {
    clear_has_value();
    if (GetArenaNoVirtual() != NULL) {
      ::tensorflow::TensorShapeProto* temp = new ::tensorflow::TensorShapeProto(*value_.shape_);
      value_.shape_ = NULL;
      return temp;
    } else {
      ::tensorflow::TensorShapeProto* temp = value_.shape_;
      value_.shape_ = NULL;
      return temp;
    }
  } else {
    return NULL;
  }
}
inline void AttrValue::set_allocated_shape(::tensorflow::TensorShapeProto* shape) {
  clear_value();
  if (shape) {
    if (GetArenaNoVirtual() != NULL &&
        ::google::protobuf::Arena::GetArena(shape) == NULL) {
      GetArenaNoVirtual()->Own(shape);
    } else if (GetArenaNoVirtual() !=
               ::google::protobuf::Arena::GetArena(shape)) {
      ::tensorflow::TensorShapeProto* new_shape = 
          ::google::protobuf::Arena::CreateMessage< ::tensorflow::TensorShapeProto >(
          GetArenaNoVirtual());
      new_shape->CopyFrom(*shape);
      shape = new_shape;
    }
    set_has_shape();
    value_.shape_ = shape;
  }
  // @@protoc_insertion_point(field_set_allocated:tensorflow.AttrValue.shape)
}
inline  ::tensorflow::TensorShapeProto* AttrValue::unsafe_arena_release_shape() {
  // @@protoc_insertion_point(field_unsafe_arena_release:tensorflow.AttrValue.shape)
  if (has_shape()) {
    clear_has_value();
    ::tensorflow::TensorShapeProto* temp = value_.shape_;
    value_.shape_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline  void AttrValue::unsafe_arena_set_allocated_shape(::tensorflow::TensorShapeProto* shape) {
  clear_value();
  if (shape) {
    set_has_shape();
    value_.shape_ = shape;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tensorflow.AttrValue.shape)
}

// optional .tensorflow.TensorProto tensor = 8;
inline bool AttrValue::has_tensor() const {
  return value_case() == kTensor;
}
inline void AttrValue::set_has_tensor() {
  _oneof_case_[0] = kTensor;
}
inline void AttrValue::clear_tensor() {
  if (has_tensor()) {
    if (GetArenaNoVirtual() == NULL) {
      delete value_.tensor_;
    }
    clear_has_value();
  }
}
inline  const ::tensorflow::TensorProto& AttrValue::tensor() const {
  // @@protoc_insertion_point(field_get:tensorflow.AttrValue.tensor)
  return has_tensor()
      ? *value_.tensor_
      : ::tensorflow::TensorProto::default_instance();
}
inline ::tensorflow::TensorProto* AttrValue::mutable_tensor() {
  if (!has_tensor()) {
    clear_value();
    set_has_tensor();
    value_.tensor_ = 
      ::google::protobuf::Arena::CreateMessage< ::tensorflow::TensorProto >(
      GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:tensorflow.AttrValue.tensor)
  return value_.tensor_;
}
inline ::tensorflow::TensorProto* AttrValue::release_tensor() {
  // @@protoc_insertion_point(field_release:tensorflow.AttrValue.tensor)
  if (has_tensor()) {
    clear_has_value();
    if (GetArenaNoVirtual() != NULL) {
      ::tensorflow::TensorProto* temp = new ::tensorflow::TensorProto(*value_.tensor_);
      value_.tensor_ = NULL;
      return temp;
    } else {
      ::tensorflow::TensorProto* temp = value_.tensor_;
      value_.tensor_ = NULL;
      return temp;
    }
  } else {
    return NULL;
  }
}
inline void AttrValue::set_allocated_tensor(::tensorflow::TensorProto* tensor) {
  clear_value();
  if (tensor) {
    if (GetArenaNoVirtual() != NULL &&
        ::google::protobuf::Arena::GetArena(tensor) == NULL) {
      GetArenaNoVirtual()->Own(tensor);
    } else if (GetArenaNoVirtual() !=
               ::google::protobuf::Arena::GetArena(tensor)) {
      ::tensorflow::TensorProto* new_tensor = 
          ::google::protobuf::Arena::CreateMessage< ::tensorflow::TensorProto >(
          GetArenaNoVirtual());
      new_tensor->CopyFrom(*tensor);
      tensor = new_tensor;
    }
    set_has_tensor();
    value_.tensor_ = tensor;
  }
  // @@protoc_insertion_point(field_set_allocated:tensorflow.AttrValue.tensor)
}
inline  ::tensorflow::TensorProto* AttrValue::unsafe_arena_release_tensor() {
  // @@protoc_insertion_point(field_unsafe_arena_release:tensorflow.AttrValue.tensor)
  if (has_tensor()) {
    clear_has_value();
    ::tensorflow::TensorProto* temp = value_.tensor_;
    value_.tensor_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline  void AttrValue::unsafe_arena_set_allocated_tensor(::tensorflow::TensorProto* tensor) {
  clear_value();
  if (tensor) {
    set_has_tensor();
    value_.tensor_ = tensor;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tensorflow.AttrValue.tensor)
}

// optional .tensorflow.AttrValue.ListValue list = 1;
inline bool AttrValue::has_list() const {
  return value_case() == kList;
}
inline void AttrValue::set_has_list() {
  _oneof_case_[0] = kList;
}
inline void AttrValue::clear_list() {
  if (has_list()) {
    if (GetArenaNoVirtual() == NULL) {
      delete value_.list_;
    }
    clear_has_value();
  }
}
inline  const ::tensorflow::AttrValue_ListValue& AttrValue::list() const {
  // @@protoc_insertion_point(field_get:tensorflow.AttrValue.list)
  return has_list()
      ? *value_.list_
      : ::tensorflow::AttrValue_ListValue::default_instance();
}
inline ::tensorflow::AttrValue_ListValue* AttrValue::mutable_list() {
  if (!has_list()) {
    clear_value();
    set_has_list();
    value_.list_ = 
      ::google::protobuf::Arena::CreateMessage< ::tensorflow::AttrValue_ListValue >(
      GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:tensorflow.AttrValue.list)
  return value_.list_;
}
inline ::tensorflow::AttrValue_ListValue* AttrValue::release_list() {
  // @@protoc_insertion_point(field_release:tensorflow.AttrValue.list)
  if (has_list()) {
    clear_has_value();
    if (GetArenaNoVirtual() != NULL) {
      ::tensorflow::AttrValue_ListValue* temp = new ::tensorflow::AttrValue_ListValue(*value_.list_);
      value_.list_ = NULL;
      return temp;
    } else {
      ::tensorflow::AttrValue_ListValue* temp = value_.list_;
      value_.list_ = NULL;
      return temp;
    }
  } else {
    return NULL;
  }
}
inline void AttrValue::set_allocated_list(::tensorflow::AttrValue_ListValue* list) {
  clear_value();
  if (list) {
    if (GetArenaNoVirtual() != NULL &&
        ::google::protobuf::Arena::GetArena(list) == NULL) {
      GetArenaNoVirtual()->Own(list);
    } else if (GetArenaNoVirtual() !=
               ::google::protobuf::Arena::GetArena(list)) {
      ::tensorflow::AttrValue_ListValue* new_list = 
          ::google::protobuf::Arena::CreateMessage< ::tensorflow::AttrValue_ListValue >(
          GetArenaNoVirtual());
      new_list->CopyFrom(*list);
      list = new_list;
    }
    set_has_list();
    value_.list_ = list;
  }
  // @@protoc_insertion_point(field_set_allocated:tensorflow.AttrValue.list)
}
inline  ::tensorflow::AttrValue_ListValue* AttrValue::unsafe_arena_release_list() {
  // @@protoc_insertion_point(field_unsafe_arena_release:tensorflow.AttrValue.list)
  if (has_list()) {
    clear_has_value();
    ::tensorflow::AttrValue_ListValue* temp = value_.list_;
    value_.list_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline  void AttrValue::unsafe_arena_set_allocated_list(::tensorflow::AttrValue_ListValue* list) {
  clear_value();
  if (list) {
    set_has_list();
    value_.list_ = list;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tensorflow.AttrValue.list)
}

// optional .tensorflow.NameAttrList func = 10;
inline bool AttrValue::has_func() const {
  return value_case() == kFunc;
}
inline void AttrValue::set_has_func() {
  _oneof_case_[0] = kFunc;
}
inline void AttrValue::clear_func() {
  if (has_func()) {
    if (GetArenaNoVirtual() == NULL) {
      delete value_.func_;
    }
    clear_has_value();
  }
}
inline  const ::tensorflow::NameAttrList& AttrValue::func() const {
  // @@protoc_insertion_point(field_get:tensorflow.AttrValue.func)
  return has_func()
      ? *value_.func_
      : ::tensorflow::NameAttrList::default_instance();
}
inline ::tensorflow::NameAttrList* AttrValue::mutable_func() {
  if (!has_func()) {
    clear_value();
    set_has_func();
    value_.func_ = 
      ::google::protobuf::Arena::CreateMessage< ::tensorflow::NameAttrList >(
      GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:tensorflow.AttrValue.func)
  return value_.func_;
}
inline ::tensorflow::NameAttrList* AttrValue::release_func() {
  // @@protoc_insertion_point(field_release:tensorflow.AttrValue.func)
  if (has_func()) {
    clear_has_value();
    if (GetArenaNoVirtual() != NULL) {
      ::tensorflow::NameAttrList* temp = new ::tensorflow::NameAttrList(*value_.func_);
      value_.func_ = NULL;
      return temp;
    } else {
      ::tensorflow::NameAttrList* temp = value_.func_;
      value_.func_ = NULL;
      return temp;
    }
  } else {
    return NULL;
  }
}
inline void AttrValue::set_allocated_func(::tensorflow::NameAttrList* func) {
  clear_value();
  if (func) {
    if (GetArenaNoVirtual() != NULL &&
        ::google::protobuf::Arena::GetArena(func) == NULL) {
      GetArenaNoVirtual()->Own(func);
    } else if (GetArenaNoVirtual() !=
               ::google::protobuf::Arena::GetArena(func)) {
      ::tensorflow::NameAttrList* new_func = 
          ::google::protobuf::Arena::CreateMessage< ::tensorflow::NameAttrList >(
          GetArenaNoVirtual());
      new_func->CopyFrom(*func);
      func = new_func;
    }
    set_has_func();
    value_.func_ = func;
  }
  // @@protoc_insertion_point(field_set_allocated:tensorflow.AttrValue.func)
}
inline  ::tensorflow::NameAttrList* AttrValue::unsafe_arena_release_func() {
  // @@protoc_insertion_point(field_unsafe_arena_release:tensorflow.AttrValue.func)
  if (has_func()) {
    clear_has_value();
    ::tensorflow::NameAttrList* temp = value_.func_;
    value_.func_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline  void AttrValue::unsafe_arena_set_allocated_func(::tensorflow::NameAttrList* func) {
  clear_value();
  if (func) {
    set_has_func();
    value_.func_ = func;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tensorflow.AttrValue.func)
}

// optional string placeholder = 9;
inline bool AttrValue::has_placeholder() const {
  return value_case() == kPlaceholder;
}
inline void AttrValue::set_has_placeholder() {
  _oneof_case_[0] = kPlaceholder;
}
inline void AttrValue::clear_placeholder() {
  if (has_placeholder()) {
    value_.placeholder_.Destroy(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
        GetArenaNoVirtual());
    clear_has_value();
  }
}
inline const ::std::string& AttrValue::placeholder() const {
  // @@protoc_insertion_point(field_get:tensorflow.AttrValue.placeholder)
  if (has_placeholder()) {
    return value_.placeholder_.Get(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  return *&::google::protobuf::internal::GetEmptyStringAlreadyInited();
}
inline void AttrValue::set_placeholder(const ::std::string& value) {
  if (!has_placeholder()) {
    clear_value();
    set_has_placeholder();
    value_.placeholder_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  value_.placeholder_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value,
      GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set:tensorflow.AttrValue.placeholder)
}
inline void AttrValue::set_placeholder(const char* value) {
  if (!has_placeholder()) {
    clear_value();
    set_has_placeholder();
    value_.placeholder_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  value_.placeholder_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(value), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_char:tensorflow.AttrValue.placeholder)
}
inline void AttrValue::set_placeholder(const char* value,
                             size_t size) {
  if (!has_placeholder()) {
    clear_value();
    set_has_placeholder();
    value_.placeholder_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  value_.placeholder_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size),
      GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_pointer:tensorflow.AttrValue.placeholder)
}
inline ::std::string* AttrValue::mutable_placeholder() {
  if (!has_placeholder()) {
    clear_value();
    set_has_placeholder();
    value_.placeholder_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  return value_.placeholder_.Mutable(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      GetArenaNoVirtual());
  // @@protoc_insertion_point(field_mutable:tensorflow.AttrValue.placeholder)
}
inline ::std::string* AttrValue::release_placeholder() {
  // @@protoc_insertion_point(field_release:tensorflow.AttrValue.placeholder)
  if (has_placeholder()) {
    clear_has_value();
    return value_.placeholder_.Release(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
        GetArenaNoVirtual());
  } else {
    return NULL;
  }
}
inline ::std::string* AttrValue::unsafe_arena_release_placeholder() {
  // @@protoc_insertion_point(field_unsafe_arena_release:tensorflow.AttrValue.placeholder)
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  if (has_placeholder()) {
    clear_has_value();
    return value_.placeholder_.UnsafeArenaRelease(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
  } else {
    return NULL;
  }
}
inline void AttrValue::set_allocated_placeholder(::std::string* placeholder) {
  if (!has_placeholder()) {
    value_.placeholder_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  clear_value();
  if (placeholder != NULL) {
    set_has_placeholder();
    value_.placeholder_.SetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), placeholder,
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_set_allocated:tensorflow.AttrValue.placeholder)
}
inline void AttrValue::unsafe_arena_set_allocated_placeholder(::std::string* placeholder) {
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  if (!has_placeholder()) {
    value_.placeholder_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  clear_value();
  if (placeholder) {
    set_has_placeholder();
    value_.placeholder_.UnsafeArenaSetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), placeholder, GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tensorflow.AttrValue.placeholder)
}

inline bool AttrValue::has_value() const {
  return value_case() != VALUE_NOT_SET;
}
inline void AttrValue::clear_has_value() {
  _oneof_case_[0] = VALUE_NOT_SET;
}
inline AttrValue::ValueCase AttrValue::value_case() const {
  return AttrValue::ValueCase(_oneof_case_[0]);
}
inline const AttrValue* AttrValue::internal_default_instance() {
  return &AttrValue_default_instance_.get();
}
// -------------------------------------------------------------------

// NameAttrList

// optional string name = 1;
inline void NameAttrList::clear_name() {
  name_.ClearToEmpty(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline const ::std::string& NameAttrList::name() const {
  // @@protoc_insertion_point(field_get:tensorflow.NameAttrList.name)
  return name_.Get(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void NameAttrList::set_name(const ::std::string& value) {
  
  name_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set:tensorflow.NameAttrList.name)
}
inline void NameAttrList::set_name(const char* value) {
  
  name_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_char:tensorflow.NameAttrList.name)
}
inline void NameAttrList::set_name(const char* value,
    size_t size) {
  
  name_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_pointer:tensorflow.NameAttrList.name)
}
inline ::std::string* NameAttrList::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:tensorflow.NameAttrList.name)
  return name_.Mutable(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline ::std::string* NameAttrList::release_name() {
  // @@protoc_insertion_point(field_release:tensorflow.NameAttrList.name)
  
  return name_.Release(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline ::std::string* NameAttrList::unsafe_arena_release_name() {
  // @@protoc_insertion_point(field_unsafe_arena_release:tensorflow.NameAttrList.name)
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  
  return name_.UnsafeArenaRelease(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      GetArenaNoVirtual());
}
inline void NameAttrList::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    
  } else {
    
  }
  name_.SetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name,
      GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_allocated:tensorflow.NameAttrList.name)
}
inline void NameAttrList::unsafe_arena_set_allocated_name(
    ::std::string* name) {
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  if (name != NULL) {
    
  } else {
    
  }
  name_.UnsafeArenaSetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      name, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tensorflow.NameAttrList.name)
}

// map<string, .tensorflow.AttrValue> attr = 2;
inline int NameAttrList::attr_size() const {
  return attr_.size();
}
inline void NameAttrList::clear_attr() {
  attr_.Clear();
}
inline const ::google::protobuf::Map< ::std::string, ::tensorflow::AttrValue >&
NameAttrList::attr() const {
  // @@protoc_insertion_point(field_map:tensorflow.NameAttrList.attr)
  return attr_.GetMap();
}
inline ::google::protobuf::Map< ::std::string, ::tensorflow::AttrValue >*
NameAttrList::mutable_attr() {
  // @@protoc_insertion_point(field_mutable_map:tensorflow.NameAttrList.attr)
  return attr_.MutableMap();
}

inline const NameAttrList* NameAttrList::internal_default_instance() {
  return &NameAttrList_default_instance_.get();
}
// -------------------------------------------------------------------

// NodeDef

// optional string name = 1;
inline void NodeDef::clear_name() {
  name_.ClearToEmpty(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline const ::std::string& NodeDef::name() const {
  // @@protoc_insertion_point(field_get:tensorflow.NodeDef.name)
  return name_.Get(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void NodeDef::set_name(const ::std::string& value) {
  
  name_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set:tensorflow.NodeDef.name)
}
inline void NodeDef::set_name(const char* value) {
  
  name_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_char:tensorflow.NodeDef.name)
}
inline void NodeDef::set_name(const char* value,
    size_t size) {
  
  name_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_pointer:tensorflow.NodeDef.name)
}
inline ::std::string* NodeDef::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:tensorflow.NodeDef.name)
  return name_.Mutable(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline ::std::string* NodeDef::release_name() {
  // @@protoc_insertion_point(field_release:tensorflow.NodeDef.name)
  
  return name_.Release(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline ::std::string* NodeDef::unsafe_arena_release_name() {
  // @@protoc_insertion_point(field_unsafe_arena_release:tensorflow.NodeDef.name)
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  
  return name_.UnsafeArenaRelease(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      GetArenaNoVirtual());
}
inline void NodeDef::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    
  } else {
    
  }
  name_.SetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name,
      GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_allocated:tensorflow.NodeDef.name)
}
inline void NodeDef::unsafe_arena_set_allocated_name(
    ::std::string* name) {
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  if (name != NULL) {
    
  } else {
    
  }
  name_.UnsafeArenaSetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      name, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tensorflow.NodeDef.name)
}

// optional string op = 2;
inline void NodeDef::clear_op() {
  op_.ClearToEmpty(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline const ::std::string& NodeDef::op() const {
  // @@protoc_insertion_point(field_get:tensorflow.NodeDef.op)
  return op_.Get(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void NodeDef::set_op(const ::std::string& value) {
  
  op_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set:tensorflow.NodeDef.op)
}
inline void NodeDef::set_op(const char* value) {
  
  op_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_char:tensorflow.NodeDef.op)
}
inline void NodeDef::set_op(const char* value,
    size_t size) {
  
  op_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_pointer:tensorflow.NodeDef.op)
}
inline ::std::string* NodeDef::mutable_op() {
  
  // @@protoc_insertion_point(field_mutable:tensorflow.NodeDef.op)
  return op_.Mutable(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline ::std::string* NodeDef::release_op() {
  // @@protoc_insertion_point(field_release:tensorflow.NodeDef.op)
  
  return op_.Release(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline ::std::string* NodeDef::unsafe_arena_release_op() {
  // @@protoc_insertion_point(field_unsafe_arena_release:tensorflow.NodeDef.op)
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  
  return op_.UnsafeArenaRelease(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      GetArenaNoVirtual());
}
inline void NodeDef::set_allocated_op(::std::string* op) {
  if (op != NULL) {
    
  } else {
    
  }
  op_.SetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), op,
      GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_allocated:tensorflow.NodeDef.op)
}
inline void NodeDef::unsafe_arena_set_allocated_op(
    ::std::string* op) {
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  if (op != NULL) {
    
  } else {
    
  }
  op_.UnsafeArenaSetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      op, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tensorflow.NodeDef.op)
}

// repeated string input = 3;
inline int NodeDef::input_size() const {
  return input_.size();
}
inline void NodeDef::clear_input() {
  input_.Clear();
}
inline const ::std::string& NodeDef::input(int index) const {
  // @@protoc_insertion_point(field_get:tensorflow.NodeDef.input)
  return input_.Get(index);
}
inline ::std::string* NodeDef::mutable_input(int index) {
  // @@protoc_insertion_point(field_mutable:tensorflow.NodeDef.input)
  return input_.Mutable(index);
}
inline void NodeDef::set_input(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:tensorflow.NodeDef.input)
  input_.Mutable(index)->assign(value);
}
inline void NodeDef::set_input(int index, const char* value) {
  input_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:tensorflow.NodeDef.input)
}
inline void NodeDef::set_input(int index, const char* value, size_t size) {
  input_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:tensorflow.NodeDef.input)
}
inline ::std::string* NodeDef::add_input() {
  // @@protoc_insertion_point(field_add_mutable:tensorflow.NodeDef.input)
  return input_.Add();
}
inline void NodeDef::add_input(const ::std::string& value) {
  input_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:tensorflow.NodeDef.input)
}
inline void NodeDef::add_input(const char* value) {
  input_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:tensorflow.NodeDef.input)
}
inline void NodeDef::add_input(const char* value, size_t size) {
  input_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:tensorflow.NodeDef.input)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
NodeDef::input() const {
  // @@protoc_insertion_point(field_list:tensorflow.NodeDef.input)
  return input_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
NodeDef::mutable_input() {
  // @@protoc_insertion_point(field_mutable_list:tensorflow.NodeDef.input)
  return &input_;
}

// optional string device = 4;
inline void NodeDef::clear_device() {
  device_.ClearToEmpty(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline const ::std::string& NodeDef::device() const {
  // @@protoc_insertion_point(field_get:tensorflow.NodeDef.device)
  return device_.Get(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void NodeDef::set_device(const ::std::string& value) {
  
  device_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set:tensorflow.NodeDef.device)
}
inline void NodeDef::set_device(const char* value) {
  
  device_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_char:tensorflow.NodeDef.device)
}
inline void NodeDef::set_device(const char* value,
    size_t size) {
  
  device_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_pointer:tensorflow.NodeDef.device)
}
inline ::std::string* NodeDef::mutable_device() {
  
  // @@protoc_insertion_point(field_mutable:tensorflow.NodeDef.device)
  return device_.Mutable(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline ::std::string* NodeDef::release_device() {
  // @@protoc_insertion_point(field_release:tensorflow.NodeDef.device)
  
  return device_.Release(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline ::std::string* NodeDef::unsafe_arena_release_device() {
  // @@protoc_insertion_point(field_unsafe_arena_release:tensorflow.NodeDef.device)
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  
  return device_.UnsafeArenaRelease(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      GetArenaNoVirtual());
}
inline void NodeDef::set_allocated_device(::std::string* device) {
  if (device != NULL) {
    
  } else {
    
  }
  device_.SetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), device,
      GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_allocated:tensorflow.NodeDef.device)
}
inline void NodeDef::unsafe_arena_set_allocated_device(
    ::std::string* device) {
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  if (device != NULL) {
    
  } else {
    
  }
  device_.UnsafeArenaSetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      device, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tensorflow.NodeDef.device)
}

// map<string, .tensorflow.AttrValue> attr = 5;
inline int NodeDef::attr_size() const {
  return attr_.size();
}
inline void NodeDef::clear_attr() {
  attr_.Clear();
}
inline const ::google::protobuf::Map< ::std::string, ::tensorflow::AttrValue >&
NodeDef::attr() const {
  // @@protoc_insertion_point(field_map:tensorflow.NodeDef.attr)
  return attr_.GetMap();
}
inline ::google::protobuf::Map< ::std::string, ::tensorflow::AttrValue >*
NodeDef::mutable_attr() {
  // @@protoc_insertion_point(field_mutable_map:tensorflow.NodeDef.attr)
  return attr_.MutableMap();
}

inline const NodeDef* NodeDef::internal_default_instance() {
  return &NodeDef_default_instance_.get();
}
// -------------------------------------------------------------------

// GraphDef

// repeated .tensorflow.NodeDef node = 1;
inline int GraphDef::node_size() const {
  return node_.size();
}
inline void GraphDef::clear_node() {
  node_.Clear();
}
inline const ::tensorflow::NodeDef& GraphDef::node(int index) const {
  // @@protoc_insertion_point(field_get:tensorflow.GraphDef.node)
  return node_.Get(index);
}
inline ::tensorflow::NodeDef* GraphDef::mutable_node(int index) {
  // @@protoc_insertion_point(field_mutable:tensorflow.GraphDef.node)
  return node_.Mutable(index);
}
inline ::tensorflow::NodeDef* GraphDef::add_node() {
  // @@protoc_insertion_point(field_add:tensorflow.GraphDef.node)
  return node_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::tensorflow::NodeDef >*
GraphDef::mutable_node() {
  // @@protoc_insertion_point(field_mutable_list:tensorflow.GraphDef.node)
  return &node_;
}
inline const ::google::protobuf::RepeatedPtrField< ::tensorflow::NodeDef >&
GraphDef::node() const {
  // @@protoc_insertion_point(field_list:tensorflow.GraphDef.node)
  return node_;
}

// optional .tensorflow.VersionDef versions = 4;
inline bool GraphDef::has_versions() const {
  return this != internal_default_instance() && versions_ != NULL;
}
inline void GraphDef::clear_versions() {
  if (GetArenaNoVirtual() == NULL && versions_ != NULL) delete versions_;
  versions_ = NULL;
}
inline const ::tensorflow::VersionDef& GraphDef::versions() const {
  // @@protoc_insertion_point(field_get:tensorflow.GraphDef.versions)
  return versions_ != NULL ? *versions_
                         : *::tensorflow::VersionDef::internal_default_instance();
}
inline ::tensorflow::VersionDef* GraphDef::mutable_versions() {
  
  if (versions_ == NULL) {
    _slow_mutable_versions();
  }
  // @@protoc_insertion_point(field_mutable:tensorflow.GraphDef.versions)
  return versions_;
}
inline ::tensorflow::VersionDef* GraphDef::release_versions() {
  // @@protoc_insertion_point(field_release:tensorflow.GraphDef.versions)
  
  if (GetArenaNoVirtual() != NULL) {
    return _slow_release_versions();
  } else {
    ::tensorflow::VersionDef* temp = versions_;
    versions_ = NULL;
    return temp;
  }
}
inline  void GraphDef::set_allocated_versions(::tensorflow::VersionDef* versions) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete versions_;
  }
  if (versions != NULL) {
    _slow_set_allocated_versions(message_arena, &versions);
  }
  versions_ = versions;
  if (versions) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:tensorflow.GraphDef.versions)
}

// optional int32 version = 3 [deprecated = true];
inline void GraphDef::clear_version() {
  version_ = 0;
}
inline ::google::protobuf::int32 GraphDef::version() const {
  // @@protoc_insertion_point(field_get:tensorflow.GraphDef.version)
  return version_;
}
inline void GraphDef::set_version(::google::protobuf::int32 value) {
  
  version_ = value;
  // @@protoc_insertion_point(field_set:tensorflow.GraphDef.version)
}

inline const GraphDef* GraphDef::internal_default_instance() {
  return &GraphDef_default_instance_.get();
}
// -------------------------------------------------------------------

// Event

// optional double wall_time = 1;
inline void Event::clear_wall_time() {
  wall_time_ = 0;
}
inline double Event::wall_time() const {
  // @@protoc_insertion_point(field_get:tensorflow.Event.wall_time)
  return wall_time_;
}
inline void Event::set_wall_time(double value) {
  
  wall_time_ = value;
  // @@protoc_insertion_point(field_set:tensorflow.Event.wall_time)
}

// optional int64 step = 2;
inline void Event::clear_step() {
  step_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 Event::step() const {
  // @@protoc_insertion_point(field_get:tensorflow.Event.step)
  return step_;
}
inline void Event::set_step(::google::protobuf::int64 value) {
  
  step_ = value;
  // @@protoc_insertion_point(field_set:tensorflow.Event.step)
}

// optional string file_version = 3;
inline bool Event::has_file_version() const {
  return what_case() == kFileVersion;
}
inline void Event::set_has_file_version() {
  _oneof_case_[0] = kFileVersion;
}
inline void Event::clear_file_version() {
  if (has_file_version()) {
    what_.file_version_.Destroy(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
        GetArenaNoVirtual());
    clear_has_what();
  }
}
inline const ::std::string& Event::file_version() const {
  // @@protoc_insertion_point(field_get:tensorflow.Event.file_version)
  if (has_file_version()) {
    return what_.file_version_.Get(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  return *&::google::protobuf::internal::GetEmptyStringAlreadyInited();
}
inline void Event::set_file_version(const ::std::string& value) {
  if (!has_file_version()) {
    clear_what();
    set_has_file_version();
    what_.file_version_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  what_.file_version_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value,
      GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set:tensorflow.Event.file_version)
}
inline void Event::set_file_version(const char* value) {
  if (!has_file_version()) {
    clear_what();
    set_has_file_version();
    what_.file_version_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  what_.file_version_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(value), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_char:tensorflow.Event.file_version)
}
inline void Event::set_file_version(const char* value,
                             size_t size) {
  if (!has_file_version()) {
    clear_what();
    set_has_file_version();
    what_.file_version_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  what_.file_version_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size),
      GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_pointer:tensorflow.Event.file_version)
}
inline ::std::string* Event::mutable_file_version() {
  if (!has_file_version()) {
    clear_what();
    set_has_file_version();
    what_.file_version_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  return what_.file_version_.Mutable(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      GetArenaNoVirtual());
  // @@protoc_insertion_point(field_mutable:tensorflow.Event.file_version)
}
inline ::std::string* Event::release_file_version() {
  // @@protoc_insertion_point(field_release:tensorflow.Event.file_version)
  if (has_file_version()) {
    clear_has_what();
    return what_.file_version_.Release(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
        GetArenaNoVirtual());
  } else {
    return NULL;
  }
}
inline ::std::string* Event::unsafe_arena_release_file_version() {
  // @@protoc_insertion_point(field_unsafe_arena_release:tensorflow.Event.file_version)
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  if (has_file_version()) {
    clear_has_what();
    return what_.file_version_.UnsafeArenaRelease(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
  } else {
    return NULL;
  }
}
inline void Event::set_allocated_file_version(::std::string* file_version) {
  if (!has_file_version()) {
    what_.file_version_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  clear_what();
  if (file_version != NULL) {
    set_has_file_version();
    what_.file_version_.SetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), file_version,
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_set_allocated:tensorflow.Event.file_version)
}
inline void Event::unsafe_arena_set_allocated_file_version(::std::string* file_version) {
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  if (!has_file_version()) {
    what_.file_version_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  clear_what();
  if (file_version) {
    set_has_file_version();
    what_.file_version_.UnsafeArenaSetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), file_version, GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tensorflow.Event.file_version)
}

// optional bytes graph_def = 4;
inline bool Event::has_graph_def() const {
  return what_case() == kGraphDef;
}
inline void Event::set_has_graph_def() {
  _oneof_case_[0] = kGraphDef;
}
inline void Event::clear_graph_def() {
  if (has_graph_def()) {
    what_.graph_def_.Destroy(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
        GetArenaNoVirtual());
    clear_has_what();
  }
}
inline const ::std::string& Event::graph_def() const {
  // @@protoc_insertion_point(field_get:tensorflow.Event.graph_def)
  if (has_graph_def()) {
    return what_.graph_def_.Get(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  return *&::google::protobuf::internal::GetEmptyStringAlreadyInited();
}
inline void Event::set_graph_def(const ::std::string& value) {
  if (!has_graph_def()) {
    clear_what();
    set_has_graph_def();
    what_.graph_def_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  what_.graph_def_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value,
      GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set:tensorflow.Event.graph_def)
}
inline void Event::set_graph_def(const char* value) {
  if (!has_graph_def()) {
    clear_what();
    set_has_graph_def();
    what_.graph_def_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  what_.graph_def_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(value), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_char:tensorflow.Event.graph_def)
}
inline void Event::set_graph_def(const void* value,
                             size_t size) {
  if (!has_graph_def()) {
    clear_what();
    set_has_graph_def();
    what_.graph_def_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  what_.graph_def_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size),
      GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_pointer:tensorflow.Event.graph_def)
}
inline ::std::string* Event::mutable_graph_def() {
  if (!has_graph_def()) {
    clear_what();
    set_has_graph_def();
    what_.graph_def_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  return what_.graph_def_.Mutable(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      GetArenaNoVirtual());
  // @@protoc_insertion_point(field_mutable:tensorflow.Event.graph_def)
}
inline ::std::string* Event::release_graph_def() {
  // @@protoc_insertion_point(field_release:tensorflow.Event.graph_def)
  if (has_graph_def()) {
    clear_has_what();
    return what_.graph_def_.Release(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
        GetArenaNoVirtual());
  } else {
    return NULL;
  }
}
inline ::std::string* Event::unsafe_arena_release_graph_def() {
  // @@protoc_insertion_point(field_unsafe_arena_release:tensorflow.Event.graph_def)
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  if (has_graph_def()) {
    clear_has_what();
    return what_.graph_def_.UnsafeArenaRelease(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
  } else {
    return NULL;
  }
}
inline void Event::set_allocated_graph_def(::std::string* graph_def) {
  if (!has_graph_def()) {
    what_.graph_def_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  clear_what();
  if (graph_def != NULL) {
    set_has_graph_def();
    what_.graph_def_.SetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), graph_def,
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_set_allocated:tensorflow.Event.graph_def)
}
inline void Event::unsafe_arena_set_allocated_graph_def(::std::string* graph_def) {
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  if (!has_graph_def()) {
    what_.graph_def_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  clear_what();
  if (graph_def) {
    set_has_graph_def();
    what_.graph_def_.UnsafeArenaSetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), graph_def, GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tensorflow.Event.graph_def)
}

// optional .tensorflow.Summary summary = 5;
inline bool Event::has_summary() const {
  return what_case() == kSummary;
}
inline void Event::set_has_summary() {
  _oneof_case_[0] = kSummary;
}
inline void Event::clear_summary() {
  if (has_summary()) {
    if (GetArenaNoVirtual() == NULL) {
      delete what_.summary_;
    }
    clear_has_what();
  }
}
inline  const ::tensorflow::Summary& Event::summary() const {
  // @@protoc_insertion_point(field_get:tensorflow.Event.summary)
  return has_summary()
      ? *what_.summary_
      : ::tensorflow::Summary::default_instance();
}
inline ::tensorflow::Summary* Event::mutable_summary() {
  if (!has_summary()) {
    clear_what();
    set_has_summary();
    what_.summary_ = 
      ::google::protobuf::Arena::CreateMessage< ::tensorflow::Summary >(
      GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:tensorflow.Event.summary)
  return what_.summary_;
}
inline ::tensorflow::Summary* Event::release_summary() {
  // @@protoc_insertion_point(field_release:tensorflow.Event.summary)
  if (has_summary()) {
    clear_has_what();
    if (GetArenaNoVirtual() != NULL) {
      ::tensorflow::Summary* temp = new ::tensorflow::Summary(*what_.summary_);
      what_.summary_ = NULL;
      return temp;
    } else {
      ::tensorflow::Summary* temp = what_.summary_;
      what_.summary_ = NULL;
      return temp;
    }
  } else {
    return NULL;
  }
}
inline void Event::set_allocated_summary(::tensorflow::Summary* summary) {
  clear_what();
  if (summary) {
    if (GetArenaNoVirtual() != NULL &&
        ::google::protobuf::Arena::GetArena(summary) == NULL) {
      GetArenaNoVirtual()->Own(summary);
    } else if (GetArenaNoVirtual() !=
               ::google::protobuf::Arena::GetArena(summary)) {
      ::tensorflow::Summary* new_summary = 
          ::google::protobuf::Arena::CreateMessage< ::tensorflow::Summary >(
          GetArenaNoVirtual());
      new_summary->CopyFrom(*summary);
      summary = new_summary;
    }
    set_has_summary();
    what_.summary_ = summary;
  }
  // @@protoc_insertion_point(field_set_allocated:tensorflow.Event.summary)
}
inline  ::tensorflow::Summary* Event::unsafe_arena_release_summary() {
  // @@protoc_insertion_point(field_unsafe_arena_release:tensorflow.Event.summary)
  if (has_summary()) {
    clear_has_what();
    ::tensorflow::Summary* temp = what_.summary_;
    what_.summary_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline  void Event::unsafe_arena_set_allocated_summary(::tensorflow::Summary* summary) {
  clear_what();
  if (summary) {
    set_has_summary();
    what_.summary_ = summary;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tensorflow.Event.summary)
}

// optional .tensorflow.LogMessage log_message = 6;
inline bool Event::has_log_message() const {
  return what_case() == kLogMessage;
}
inline void Event::set_has_log_message() {
  _oneof_case_[0] = kLogMessage;
}
inline void Event::clear_log_message() {
  if (has_log_message()) {
    if (GetArenaNoVirtual() == NULL) {
      delete what_.log_message_;
    }
    clear_has_what();
  }
}
inline  const ::tensorflow::LogMessage& Event::log_message() const {
  // @@protoc_insertion_point(field_get:tensorflow.Event.log_message)
  return has_log_message()
      ? *what_.log_message_
      : ::tensorflow::LogMessage::default_instance();
}
inline ::tensorflow::LogMessage* Event::mutable_log_message() {
  if (!has_log_message()) {
    clear_what();
    set_has_log_message();
    what_.log_message_ = 
      ::google::protobuf::Arena::CreateMessage< ::tensorflow::LogMessage >(
      GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:tensorflow.Event.log_message)
  return what_.log_message_;
}
inline ::tensorflow::LogMessage* Event::release_log_message() {
  // @@protoc_insertion_point(field_release:tensorflow.Event.log_message)
  if (has_log_message()) {
    clear_has_what();
    if (GetArenaNoVirtual() != NULL) {
      ::tensorflow::LogMessage* temp = new ::tensorflow::LogMessage(*what_.log_message_);
      what_.log_message_ = NULL;
      return temp;
    } else {
      ::tensorflow::LogMessage* temp = what_.log_message_;
      what_.log_message_ = NULL;
      return temp;
    }
  } else {
    return NULL;
  }
}
inline void Event::set_allocated_log_message(::tensorflow::LogMessage* log_message) {
  clear_what();
  if (log_message) {
    if (GetArenaNoVirtual() != NULL &&
        ::google::protobuf::Arena::GetArena(log_message) == NULL) {
      GetArenaNoVirtual()->Own(log_message);
    } else if (GetArenaNoVirtual() !=
               ::google::protobuf::Arena::GetArena(log_message)) {
      ::tensorflow::LogMessage* new_log_message = 
          ::google::protobuf::Arena::CreateMessage< ::tensorflow::LogMessage >(
          GetArenaNoVirtual());
      new_log_message->CopyFrom(*log_message);
      log_message = new_log_message;
    }
    set_has_log_message();
    what_.log_message_ = log_message;
  }
  // @@protoc_insertion_point(field_set_allocated:tensorflow.Event.log_message)
}
inline  ::tensorflow::LogMessage* Event::unsafe_arena_release_log_message() {
  // @@protoc_insertion_point(field_unsafe_arena_release:tensorflow.Event.log_message)
  if (has_log_message()) {
    clear_has_what();
    ::tensorflow::LogMessage* temp = what_.log_message_;
    what_.log_message_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline  void Event::unsafe_arena_set_allocated_log_message(::tensorflow::LogMessage* log_message) {
  clear_what();
  if (log_message) {
    set_has_log_message();
    what_.log_message_ = log_message;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tensorflow.Event.log_message)
}

// optional .tensorflow.SessionLog session_log = 7;
inline bool Event::has_session_log() const {
  return what_case() == kSessionLog;
}
inline void Event::set_has_session_log() {
  _oneof_case_[0] = kSessionLog;
}
inline void Event::clear_session_log() {
  if (has_session_log()) {
    if (GetArenaNoVirtual() == NULL) {
      delete what_.session_log_;
    }
    clear_has_what();
  }
}
inline  const ::tensorflow::SessionLog& Event::session_log() const {
  // @@protoc_insertion_point(field_get:tensorflow.Event.session_log)
  return has_session_log()
      ? *what_.session_log_
      : ::tensorflow::SessionLog::default_instance();
}
inline ::tensorflow::SessionLog* Event::mutable_session_log() {
  if (!has_session_log()) {
    clear_what();
    set_has_session_log();
    what_.session_log_ = 
      ::google::protobuf::Arena::CreateMessage< ::tensorflow::SessionLog >(
      GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:tensorflow.Event.session_log)
  return what_.session_log_;
}
inline ::tensorflow::SessionLog* Event::release_session_log() {
  // @@protoc_insertion_point(field_release:tensorflow.Event.session_log)
  if (has_session_log()) {
    clear_has_what();
    if (GetArenaNoVirtual() != NULL) {
      ::tensorflow::SessionLog* temp = new ::tensorflow::SessionLog(*what_.session_log_);
      what_.session_log_ = NULL;
      return temp;
    } else {
      ::tensorflow::SessionLog* temp = what_.session_log_;
      what_.session_log_ = NULL;
      return temp;
    }
  } else {
    return NULL;
  }
}
inline void Event::set_allocated_session_log(::tensorflow::SessionLog* session_log) {
  clear_what();
  if (session_log) {
    if (GetArenaNoVirtual() != NULL &&
        ::google::protobuf::Arena::GetArena(session_log) == NULL) {
      GetArenaNoVirtual()->Own(session_log);
    } else if (GetArenaNoVirtual() !=
               ::google::protobuf::Arena::GetArena(session_log)) {
      ::tensorflow::SessionLog* new_session_log = 
          ::google::protobuf::Arena::CreateMessage< ::tensorflow::SessionLog >(
          GetArenaNoVirtual());
      new_session_log->CopyFrom(*session_log);
      session_log = new_session_log;
    }
    set_has_session_log();
    what_.session_log_ = session_log;
  }
  // @@protoc_insertion_point(field_set_allocated:tensorflow.Event.session_log)
}
inline  ::tensorflow::SessionLog* Event::unsafe_arena_release_session_log() {
  // @@protoc_insertion_point(field_unsafe_arena_release:tensorflow.Event.session_log)
  if (has_session_log()) {
    clear_has_what();
    ::tensorflow::SessionLog* temp = what_.session_log_;
    what_.session_log_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline  void Event::unsafe_arena_set_allocated_session_log(::tensorflow::SessionLog* session_log) {
  clear_what();
  if (session_log) {
    set_has_session_log();
    what_.session_log_ = session_log;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tensorflow.Event.session_log)
}

// optional .tensorflow.TaggedRunMetadata tagged_run_metadata = 8;
inline bool Event::has_tagged_run_metadata() const {
  return what_case() == kTaggedRunMetadata;
}
inline void Event::set_has_tagged_run_metadata() {
  _oneof_case_[0] = kTaggedRunMetadata;
}
inline void Event::clear_tagged_run_metadata() {
  if (has_tagged_run_metadata()) {
    if (GetArenaNoVirtual() == NULL) {
      delete what_.tagged_run_metadata_;
    }
    clear_has_what();
  }
}
inline  const ::tensorflow::TaggedRunMetadata& Event::tagged_run_metadata() const {
  // @@protoc_insertion_point(field_get:tensorflow.Event.tagged_run_metadata)
  return has_tagged_run_metadata()
      ? *what_.tagged_run_metadata_
      : ::tensorflow::TaggedRunMetadata::default_instance();
}
inline ::tensorflow::TaggedRunMetadata* Event::mutable_tagged_run_metadata() {
  if (!has_tagged_run_metadata()) {
    clear_what();
    set_has_tagged_run_metadata();
    what_.tagged_run_metadata_ = 
      ::google::protobuf::Arena::CreateMessage< ::tensorflow::TaggedRunMetadata >(
      GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:tensorflow.Event.tagged_run_metadata)
  return what_.tagged_run_metadata_;
}
inline ::tensorflow::TaggedRunMetadata* Event::release_tagged_run_metadata() {
  // @@protoc_insertion_point(field_release:tensorflow.Event.tagged_run_metadata)
  if (has_tagged_run_metadata()) {
    clear_has_what();
    if (GetArenaNoVirtual() != NULL) {
      ::tensorflow::TaggedRunMetadata* temp = new ::tensorflow::TaggedRunMetadata(*what_.tagged_run_metadata_);
      what_.tagged_run_metadata_ = NULL;
      return temp;
    } else {
      ::tensorflow::TaggedRunMetadata* temp = what_.tagged_run_metadata_;
      what_.tagged_run_metadata_ = NULL;
      return temp;
    }
  } else {
    return NULL;
  }
}
inline void Event::set_allocated_tagged_run_metadata(::tensorflow::TaggedRunMetadata* tagged_run_metadata) {
  clear_what();
  if (tagged_run_metadata) {
    if (GetArenaNoVirtual() != NULL &&
        ::google::protobuf::Arena::GetArena(tagged_run_metadata) == NULL) {
      GetArenaNoVirtual()->Own(tagged_run_metadata);
    } else if (GetArenaNoVirtual() !=
               ::google::protobuf::Arena::GetArena(tagged_run_metadata)) {
      ::tensorflow::TaggedRunMetadata* new_tagged_run_metadata = 
          ::google::protobuf::Arena::CreateMessage< ::tensorflow::TaggedRunMetadata >(
          GetArenaNoVirtual());
      new_tagged_run_metadata->CopyFrom(*tagged_run_metadata);
      tagged_run_metadata = new_tagged_run_metadata;
    }
    set_has_tagged_run_metadata();
    what_.tagged_run_metadata_ = tagged_run_metadata;
  }
  // @@protoc_insertion_point(field_set_allocated:tensorflow.Event.tagged_run_metadata)
}
inline  ::tensorflow::TaggedRunMetadata* Event::unsafe_arena_release_tagged_run_metadata() {
  // @@protoc_insertion_point(field_unsafe_arena_release:tensorflow.Event.tagged_run_metadata)
  if (has_tagged_run_metadata()) {
    clear_has_what();
    ::tensorflow::TaggedRunMetadata* temp = what_.tagged_run_metadata_;
    what_.tagged_run_metadata_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline  void Event::unsafe_arena_set_allocated_tagged_run_metadata(::tensorflow::TaggedRunMetadata* tagged_run_metadata) {
  clear_what();
  if (tagged_run_metadata) {
    set_has_tagged_run_metadata();
    what_.tagged_run_metadata_ = tagged_run_metadata;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tensorflow.Event.tagged_run_metadata)
}

// optional bytes meta_graph_def = 9;
inline bool Event::has_meta_graph_def() const {
  return what_case() == kMetaGraphDef;
}
inline void Event::set_has_meta_graph_def() {
  _oneof_case_[0] = kMetaGraphDef;
}
inline void Event::clear_meta_graph_def() {
  if (has_meta_graph_def()) {
    what_.meta_graph_def_.Destroy(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
        GetArenaNoVirtual());
    clear_has_what();
  }
}
inline const ::std::string& Event::meta_graph_def() const {
  // @@protoc_insertion_point(field_get:tensorflow.Event.meta_graph_def)
  if (has_meta_graph_def()) {
    return what_.meta_graph_def_.Get(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  return *&::google::protobuf::internal::GetEmptyStringAlreadyInited();
}
inline void Event::set_meta_graph_def(const ::std::string& value) {
  if (!has_meta_graph_def()) {
    clear_what();
    set_has_meta_graph_def();
    what_.meta_graph_def_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  what_.meta_graph_def_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value,
      GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set:tensorflow.Event.meta_graph_def)
}
inline void Event::set_meta_graph_def(const char* value) {
  if (!has_meta_graph_def()) {
    clear_what();
    set_has_meta_graph_def();
    what_.meta_graph_def_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  what_.meta_graph_def_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(value), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_char:tensorflow.Event.meta_graph_def)
}
inline void Event::set_meta_graph_def(const void* value,
                             size_t size) {
  if (!has_meta_graph_def()) {
    clear_what();
    set_has_meta_graph_def();
    what_.meta_graph_def_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  what_.meta_graph_def_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size),
      GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_pointer:tensorflow.Event.meta_graph_def)
}
inline ::std::string* Event::mutable_meta_graph_def() {
  if (!has_meta_graph_def()) {
    clear_what();
    set_has_meta_graph_def();
    what_.meta_graph_def_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  return what_.meta_graph_def_.Mutable(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      GetArenaNoVirtual());
  // @@protoc_insertion_point(field_mutable:tensorflow.Event.meta_graph_def)
}
inline ::std::string* Event::release_meta_graph_def() {
  // @@protoc_insertion_point(field_release:tensorflow.Event.meta_graph_def)
  if (has_meta_graph_def()) {
    clear_has_what();
    return what_.meta_graph_def_.Release(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
        GetArenaNoVirtual());
  } else {
    return NULL;
  }
}
inline ::std::string* Event::unsafe_arena_release_meta_graph_def() {
  // @@protoc_insertion_point(field_unsafe_arena_release:tensorflow.Event.meta_graph_def)
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  if (has_meta_graph_def()) {
    clear_has_what();
    return what_.meta_graph_def_.UnsafeArenaRelease(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
  } else {
    return NULL;
  }
}
inline void Event::set_allocated_meta_graph_def(::std::string* meta_graph_def) {
  if (!has_meta_graph_def()) {
    what_.meta_graph_def_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  clear_what();
  if (meta_graph_def != NULL) {
    set_has_meta_graph_def();
    what_.meta_graph_def_.SetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), meta_graph_def,
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_set_allocated:tensorflow.Event.meta_graph_def)
}
inline void Event::unsafe_arena_set_allocated_meta_graph_def(::std::string* meta_graph_def) {
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  if (!has_meta_graph_def()) {
    what_.meta_graph_def_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  clear_what();
  if (meta_graph_def) {
    set_has_meta_graph_def();
    what_.meta_graph_def_.UnsafeArenaSetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), meta_graph_def, GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tensorflow.Event.meta_graph_def)
}

inline bool Event::has_what() const {
  return what_case() != WHAT_NOT_SET;
}
inline void Event::clear_has_what() {
  _oneof_case_[0] = WHAT_NOT_SET;
}
inline Event::WhatCase Event::what_case() const {
  return Event::WhatCase(_oneof_case_[0]);
}
inline const Event* Event::internal_default_instance() {
  return &Event_default_instance_.get();
}
// -------------------------------------------------------------------

// LogMessage

// optional .tensorflow.LogMessage.Level level = 1;
inline void LogMessage::clear_level() {
  level_ = 0;
}
inline ::tensorflow::LogMessage_Level LogMessage::level() const {
  // @@protoc_insertion_point(field_get:tensorflow.LogMessage.level)
  return static_cast< ::tensorflow::LogMessage_Level >(level_);
}
inline void LogMessage::set_level(::tensorflow::LogMessage_Level value) {
  
  level_ = value;
  // @@protoc_insertion_point(field_set:tensorflow.LogMessage.level)
}

// optional string message = 2;
inline void LogMessage::clear_message() {
  message_.ClearToEmpty(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline const ::std::string& LogMessage::message() const {
  // @@protoc_insertion_point(field_get:tensorflow.LogMessage.message)
  return message_.Get(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void LogMessage::set_message(const ::std::string& value) {
  
  message_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set:tensorflow.LogMessage.message)
}
inline void LogMessage::set_message(const char* value) {
  
  message_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_char:tensorflow.LogMessage.message)
}
inline void LogMessage::set_message(const char* value,
    size_t size) {
  
  message_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_pointer:tensorflow.LogMessage.message)
}
inline ::std::string* LogMessage::mutable_message() {
  
  // @@protoc_insertion_point(field_mutable:tensorflow.LogMessage.message)
  return message_.Mutable(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline ::std::string* LogMessage::release_message() {
  // @@protoc_insertion_point(field_release:tensorflow.LogMessage.message)
  
  return message_.Release(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline ::std::string* LogMessage::unsafe_arena_release_message() {
  // @@protoc_insertion_point(field_unsafe_arena_release:tensorflow.LogMessage.message)
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  
  return message_.UnsafeArenaRelease(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      GetArenaNoVirtual());
}
inline void LogMessage::set_allocated_message(::std::string* message) {
  if (message != NULL) {
    
  } else {
    
  }
  message_.SetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), message,
      GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_allocated:tensorflow.LogMessage.message)
}
inline void LogMessage::unsafe_arena_set_allocated_message(
    ::std::string* message) {
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  if (message != NULL) {
    
  } else {
    
  }
  message_.UnsafeArenaSetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      message, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tensorflow.LogMessage.message)
}

inline const LogMessage* LogMessage::internal_default_instance() {
  return &LogMessage_default_instance_.get();
}
// -------------------------------------------------------------------

// SessionLog

// optional .tensorflow.SessionLog.SessionStatus status = 1;
inline void SessionLog::clear_status() {
  status_ = 0;
}
inline ::tensorflow::SessionLog_SessionStatus SessionLog::status() const {
  // @@protoc_insertion_point(field_get:tensorflow.SessionLog.status)
  return static_cast< ::tensorflow::SessionLog_SessionStatus >(status_);
}
inline void SessionLog::set_status(::tensorflow::SessionLog_SessionStatus value) {
  
  status_ = value;
  // @@protoc_insertion_point(field_set:tensorflow.SessionLog.status)
}

// optional string checkpoint_path = 2;
inline void SessionLog::clear_checkpoint_path() {
  checkpoint_path_.ClearToEmpty(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline const ::std::string& SessionLog::checkpoint_path() const {
  // @@protoc_insertion_point(field_get:tensorflow.SessionLog.checkpoint_path)
  return checkpoint_path_.Get(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SessionLog::set_checkpoint_path(const ::std::string& value) {
  
  checkpoint_path_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set:tensorflow.SessionLog.checkpoint_path)
}
inline void SessionLog::set_checkpoint_path(const char* value) {
  
  checkpoint_path_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_char:tensorflow.SessionLog.checkpoint_path)
}
inline void SessionLog::set_checkpoint_path(const char* value,
    size_t size) {
  
  checkpoint_path_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_pointer:tensorflow.SessionLog.checkpoint_path)
}
inline ::std::string* SessionLog::mutable_checkpoint_path() {
  
  // @@protoc_insertion_point(field_mutable:tensorflow.SessionLog.checkpoint_path)
  return checkpoint_path_.Mutable(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline ::std::string* SessionLog::release_checkpoint_path() {
  // @@protoc_insertion_point(field_release:tensorflow.SessionLog.checkpoint_path)
  
  return checkpoint_path_.Release(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline ::std::string* SessionLog::unsafe_arena_release_checkpoint_path() {
  // @@protoc_insertion_point(field_unsafe_arena_release:tensorflow.SessionLog.checkpoint_path)
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  
  return checkpoint_path_.UnsafeArenaRelease(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      GetArenaNoVirtual());
}
inline void SessionLog::set_allocated_checkpoint_path(::std::string* checkpoint_path) {
  if (checkpoint_path != NULL) {
    
  } else {
    
  }
  checkpoint_path_.SetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), checkpoint_path,
      GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_allocated:tensorflow.SessionLog.checkpoint_path)
}
inline void SessionLog::unsafe_arena_set_allocated_checkpoint_path(
    ::std::string* checkpoint_path) {
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  if (checkpoint_path != NULL) {
    
  } else {
    
  }
  checkpoint_path_.UnsafeArenaSetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      checkpoint_path, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tensorflow.SessionLog.checkpoint_path)
}

// optional string msg = 3;
inline void SessionLog::clear_msg() {
  msg_.ClearToEmpty(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline const ::std::string& SessionLog::msg() const {
  // @@protoc_insertion_point(field_get:tensorflow.SessionLog.msg)
  return msg_.Get(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SessionLog::set_msg(const ::std::string& value) {
  
  msg_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set:tensorflow.SessionLog.msg)
}
inline void SessionLog::set_msg(const char* value) {
  
  msg_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_char:tensorflow.SessionLog.msg)
}
inline void SessionLog::set_msg(const char* value,
    size_t size) {
  
  msg_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_pointer:tensorflow.SessionLog.msg)
}
inline ::std::string* SessionLog::mutable_msg() {
  
  // @@protoc_insertion_point(field_mutable:tensorflow.SessionLog.msg)
  return msg_.Mutable(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline ::std::string* SessionLog::release_msg() {
  // @@protoc_insertion_point(field_release:tensorflow.SessionLog.msg)
  
  return msg_.Release(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline ::std::string* SessionLog::unsafe_arena_release_msg() {
  // @@protoc_insertion_point(field_unsafe_arena_release:tensorflow.SessionLog.msg)
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  
  return msg_.UnsafeArenaRelease(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      GetArenaNoVirtual());
}
inline void SessionLog::set_allocated_msg(::std::string* msg) {
  if (msg != NULL) {
    
  } else {
    
  }
  msg_.SetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), msg,
      GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_allocated:tensorflow.SessionLog.msg)
}
inline void SessionLog::unsafe_arena_set_allocated_msg(
    ::std::string* msg) {
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  if (msg != NULL) {
    
  } else {
    
  }
  msg_.UnsafeArenaSetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      msg, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tensorflow.SessionLog.msg)
}

inline const SessionLog* SessionLog::internal_default_instance() {
  return &SessionLog_default_instance_.get();
}
// -------------------------------------------------------------------

// TaggedRunMetadata

// optional string tag = 1;
inline void TaggedRunMetadata::clear_tag() {
  tag_.ClearToEmpty(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline const ::std::string& TaggedRunMetadata::tag() const {
  // @@protoc_insertion_point(field_get:tensorflow.TaggedRunMetadata.tag)
  return tag_.Get(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TaggedRunMetadata::set_tag(const ::std::string& value) {
  
  tag_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set:tensorflow.TaggedRunMetadata.tag)
}
inline void TaggedRunMetadata::set_tag(const char* value) {
  
  tag_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_char:tensorflow.TaggedRunMetadata.tag)
}
inline void TaggedRunMetadata::set_tag(const char* value,
    size_t size) {
  
  tag_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_pointer:tensorflow.TaggedRunMetadata.tag)
}
inline ::std::string* TaggedRunMetadata::mutable_tag() {
  
  // @@protoc_insertion_point(field_mutable:tensorflow.TaggedRunMetadata.tag)
  return tag_.Mutable(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline ::std::string* TaggedRunMetadata::release_tag() {
  // @@protoc_insertion_point(field_release:tensorflow.TaggedRunMetadata.tag)
  
  return tag_.Release(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline ::std::string* TaggedRunMetadata::unsafe_arena_release_tag() {
  // @@protoc_insertion_point(field_unsafe_arena_release:tensorflow.TaggedRunMetadata.tag)
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  
  return tag_.UnsafeArenaRelease(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      GetArenaNoVirtual());
}
inline void TaggedRunMetadata::set_allocated_tag(::std::string* tag) {
  if (tag != NULL) {
    
  } else {
    
  }
  tag_.SetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), tag,
      GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_allocated:tensorflow.TaggedRunMetadata.tag)
}
inline void TaggedRunMetadata::unsafe_arena_set_allocated_tag(
    ::std::string* tag) {
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  if (tag != NULL) {
    
  } else {
    
  }
  tag_.UnsafeArenaSetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      tag, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tensorflow.TaggedRunMetadata.tag)
}

// optional bytes run_metadata = 2;
inline void TaggedRunMetadata::clear_run_metadata() {
  run_metadata_.ClearToEmpty(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline const ::std::string& TaggedRunMetadata::run_metadata() const {
  // @@protoc_insertion_point(field_get:tensorflow.TaggedRunMetadata.run_metadata)
  return run_metadata_.Get(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TaggedRunMetadata::set_run_metadata(const ::std::string& value) {
  
  run_metadata_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set:tensorflow.TaggedRunMetadata.run_metadata)
}
inline void TaggedRunMetadata::set_run_metadata(const char* value) {
  
  run_metadata_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_char:tensorflow.TaggedRunMetadata.run_metadata)
}
inline void TaggedRunMetadata::set_run_metadata(const void* value,
    size_t size) {
  
  run_metadata_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_pointer:tensorflow.TaggedRunMetadata.run_metadata)
}
inline ::std::string* TaggedRunMetadata::mutable_run_metadata() {
  
  // @@protoc_insertion_point(field_mutable:tensorflow.TaggedRunMetadata.run_metadata)
  return run_metadata_.Mutable(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline ::std::string* TaggedRunMetadata::release_run_metadata() {
  // @@protoc_insertion_point(field_release:tensorflow.TaggedRunMetadata.run_metadata)
  
  return run_metadata_.Release(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline ::std::string* TaggedRunMetadata::unsafe_arena_release_run_metadata() {
  // @@protoc_insertion_point(field_unsafe_arena_release:tensorflow.TaggedRunMetadata.run_metadata)
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  
  return run_metadata_.UnsafeArenaRelease(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      GetArenaNoVirtual());
}
inline void TaggedRunMetadata::set_allocated_run_metadata(::std::string* run_metadata) {
  if (run_metadata != NULL) {
    
  } else {
    
  }
  run_metadata_.SetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), run_metadata,
      GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_allocated:tensorflow.TaggedRunMetadata.run_metadata)
}
inline void TaggedRunMetadata::unsafe_arena_set_allocated_run_metadata(
    ::std::string* run_metadata) {
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  if (run_metadata != NULL) {
    
  } else {
    
  }
  run_metadata_.UnsafeArenaSetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      run_metadata, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tensorflow.TaggedRunMetadata.run_metadata)
}

inline const TaggedRunMetadata* TaggedRunMetadata::internal_default_instance() {
  return &TaggedRunMetadata_default_instance_.get();
}
#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace tensorflow

#ifndef SWIG
namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::tensorflow::LogMessage_Level> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::tensorflow::LogMessage_Level>() {
  return ::tensorflow::LogMessage_Level_descriptor();
}
template <> struct is_proto_enum< ::tensorflow::SessionLog_SessionStatus> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::tensorflow::SessionLog_SessionStatus>() {
  return ::tensorflow::SessionLog_SessionStatus_descriptor();
}
template <> struct is_proto_enum< ::tensorflow::DataType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::tensorflow::DataType>() {
  return ::tensorflow::DataType_descriptor();
}

}  // namespace protobuf
}  // namespace google
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_tensorboard_2eproto__INCLUDED
